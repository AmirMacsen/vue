{"./":{"url":"./","title":"项目介绍","keywords":"","body":"Vue语法基础案例和总结 10 words "},"chapter1/0-README.html":{"url":"chapter1/0-README.html","title":"第一章","keywords":"","body":"README 第一章主要学习vue的基础语法，包括事件绑定、列表渲染、过滤器、自定义指令等。 33 words "},"chapter1/1-Vue概述.html":{"url":"chapter1/1-Vue概述.html","title":"1. Vue概述","keywords":"","body":"Vue是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 特点如下： 组件化模式，提高代码复用率，让代码更好的维护 声明式编码，让编码人员无需直接操作DOM，提高开发效率 使用虚拟DOM+diff算法，尽量复用DOM节点 185 words "},"chapter1/2-Hello,World.html":{"url":"chapter1/2-Hello,World.html","title":"2. Hello,Vue","keywords":"","body":"🛴Code Title 插值语法： Hello, 指令语法： 百度1 百度2 百度3 Vue.config.productionTip = false //创建一个vue实例 const x = new Vue({ el: \"#root\", //el指定当前vue实例为哪个容器服务，通常为css选择器字符串 data: {//data用于存储数据，数据供el指定的容器使用，值暂时写成一个对象 name: \"Vue\", url: \"www.baidu.com\" } }) 🚩总结 Vue必须创建一个Vue实例，且需要传入一个配置对象 root容器里面的代码仍然遵循html规范，只不过混入了一些特殊的html语法 root容器里面的代码被称为Vue模板 容器和Vue实例是一一对应的关系 中可以是js表达式或者data中的属性一个data中的数据发生改变，页面中用到该数据的地方就会发生更新 288 words "},"chapter1/3-模板语法.html":{"url":"chapter1/3-模板语法.html","title":"3. 模板语法","keywords":"","body":"🛴分类 插值语法： 用于解析标签体内容 ,xxx是js表达式，且是可以在data中读取到的属性 指令语法：v-bind,v-if... 用于解析标签（标签属性、标签体内容、绑定事件） 其中v-bind:可以简写成: 🛴指令语法 指令语法将根据指令后面双引号里面的内容当成js表达式去执行 🛴code Title 插值语法： Hello, 指令语法： 百度1 百度2 百度3 Vue.config.productionTip = false //创建一个vue实例 const x = new Vue({ el: \"#root\", //el指定当前vue实例为哪个容器服务，通常为css选择器字符串 data: {//data用于存储数据，数据供el指定的容器使用，值暂时写成一个对象 name: \"Vue\", url: \"www.baidu.com\" } }) 267 words "},"chapter1/4-数据绑定.html":{"url":"chapter1/4-数据绑定.html","title":"4. 数据绑定","keywords":"","body":"🛴单项绑定 v-bind：单项绑定可以用在任何元素上，单项绑定只能获取data中的值，但是页面上修改之后无法修改vm的值，vm的值修改之后会重新渲染template 🛴双向绑定 v-model：只能用在表单类元素上，这类元素都有Value值，双向绑定任何一方修改值，都会使得对方的值发生变化，双方保持一致 🛴code Title 单向数据绑定： 双向数据绑定： Vue.config.productionTip = false const v = new Vue({ // el: \"#root\", data() { console.log(this) return{ name: \"jack\" } } }) setTimeout(()=>{ v.$mount(\"#root\") },1000) 204 words "},"chapter1/5-el与data的两种写法.html":{"url":"chapter1/5-el与data的两种写法.html","title":"5. el与data的两种写法","keywords":"","body":"🛴el的写法 在创建Vue实例的时候绑定 new Vue({ el:\"#root\", }) 使用Vue原型对象绑定 const vm = new Vue({ data:{ name:\"jack\" } }) vm.$mount(\"#root\") 🛴data的写法 对象式 const vm = new Vue({ data:{ name:\"jack\", age:\"18\", } }) 函数式 函数必须有返回值，返回值是一个对象，谁调用这个函数？函数的this为vue对象，所以是vue帮我们调用这个函数。 一般的，建议所有vue中的函数不要写成箭头函数，因为箭头函数的this是window //写法1 data:function(){ return { name:\"jack\" } } //写法2 data(){ return{ name:\"jack\" } } 174 words "},"chapter1/6-MVVM模型.html":{"url":"chapter1/6-MVVM模型.html","title":"6. MVVM模型","keywords":"","body":"🛴MVVM简介 M：model，负责业务逻辑以及和服务端进行交互 V：view，模板template，转化数据模型通过UI展示 VM：视图模型，Vue对象实例，用来连接model和view 🚩总结 data中所有的属性，最终都出现在了VM身上 VM上所有的属性，以及Vue原型上所有的属性，在Vue模板中都可以直接使用 123 words "},"chapter1/7-数据代理.html":{"url":"chapter1/7-数据代理.html","title":"7. 数据代理","keywords":"","body":"🛴Object.defineProperty 三个属性 enumerable：默认为false，如果设置为true，则可以被枚举 writable：默认为false，如果设置为true，则可以被修改 configurable：默认为false，如果设置为true，则可以被删除 两个方法 get(){}：如果有人要获取定义的属性，则调用这个方法 set(){}：如果有人要修改定义的属性，则嗲用这个方法 注意：以上属性和方法同时定义的时候可能会报错 🛴使用举例 回顾Object.defineProperty let number = 18 let person = { name:\"张三\", gender:\"男\", } Object.defineProperty(person,'age',{ // value:number, enumerable:true, //如果设置为false，则不可枚举，默认为false // writable:true, //如果设置为false，则不可以修改，默认为false configurable:true, //控制属性是否可以被删除，默认为false get(){ console.log(\"有人要获取age属性的值了\") return number }, set(value){ console.log(\"有人要设置set的value了\") number = value } }) console.log(Object.keys(person)) console.log(person) 🛴何为数据代理 通过一个对象代理对另一个对象中属性的操作（读/写） Vue中使用数据代理 Title 你好， 你好， const vm = new Vue({ el: \"#root\", data: { name:\"jack\", address:\"shenzhen\", } }) console.log(vm) 调试： 上图的VM._data实际上才是我们定义的data 数据代理图示 Vue中的数据代理：通过VM对象代理data中的属性操作 原理 通过Object.defineProperty()把data对象中的所有属性添加到VM上，为每一个添加到VM的属性增加一个getter和setter方法，在getter和setter内部操作data中的属性 481 words "},"chapter1/8-事件绑定.html":{"url":"chapter1/8-事件绑定.html","title":"8. 事件绑定","keywords":"","body":"🛴简单应用 Title 点我提示信息 点我提示信息 点我提示信息 Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name: \"jack\" }, methods:{ showInfo(event){ console.log(event.target.innerText) alert(\"同学你好1\") console.log(this)//vm }, //箭头函数：this为window showInfo2:(event)=>{ console.log(event.target.innerText) console.log(this)//window alert(\"同学你好2\") }, //可以传参 showInfo3:(number,event)=>{ console.log(event.target.innerText) console.log(this)//window alert(\"同学你好\"+number) } } }) 效果 总结 使用v-on:xxx或者@绑定事件，xxx是事件名 事件的回调需要配置在methods对象中，最终会在VM上 methods中配置的函数，不要用箭头函数，否则this就不是VM了 @click=\"showInfo\"和@click=”showInfo($event)“的效果一致，但是后者可以传参 🛴事件修饰符 阻止默认事件prevent 默认事件就是html元素本身的事件，比如点击a标签会打开页面等 阻止默认事件 showInfo阻止默认事件 showInfo阻止默认事件 showInfo不阻止默认事件 Vue.config.productionTip = true const vm = new Vue({ el:\"#root\", data:{ name:\"jack\", }, methods:{ showInfo(e){ e.preventDefault() alert(\"hello world\") }, showInfo2(e){ alert(\"hello world\") } } }) 效果： 阻止冒泡事件stop Title .demo1{ height: 20px; } .div1{ padding: 50px; background-color: skyblue; } .div2{ padding: 100px; background-color: orange; } .div3{ padding: 100px; background-color: gray; } Vue.config.productionTip = false const vm = new Vue({ el:'#root', data:{ name:\"jack\" }, methods:{ showMsg(msg){ alert(msg) } } }) 效果： 使用@click.stop阻止事件冒泡 使用event.stopPropagation()阻止事件冒泡 事件只触发一次 Title .demo1{ height: 20px; } .div1{ padding: 50px; background-color: skyblue; } .div2{ padding: 100px; background-color: orange; } .div3{ padding: 100px; background-color: gray; } 可以重复点击 只能点击一次 Vue.config.productionTip = false const vm = new Vue({ el:'#root', data:{ name:\"jack\" }, methods:{ showMsg(msg){ alert(msg) } } }) 效果： 捕获事件模式capture Title .demo1{ height: 20px; } .div1{ padding: 50px; background-color: skyblue; } .div2{ padding: 100px; background-color: orange; } .div3{ padding: 100px; background-color: gray; } Vue.config.productionTip = false const vm = new Vue({ el:'#root', data:{ name:\"jack\" }, methods:{ showMsg(msg){ alert(msg) } } }) 效果： 正常的捕获阶段是由外向内的，冒泡阶段是由外向内的。 没有加capture的时候，弹出的顺序应该是2-1，加capture事件的捕获顺序就改变了。 只有e.target是当前操作元素时才触发事件self Title .demo1{ height: 20px; } .div1{ padding: 50px; background-color: skyblue; } .div2{ padding: 100px; background-color: orange; } .div3{ padding: 100px; background-color: gray; } 点击触发事件 Vue.config.productionTip = false const vm = new Vue({ el:'#root', data:{ name:\"jack\" }, methods:{ showMsg(msg){ alert(msg) } } }) 效果： 🛴键盘事件 Title 欢迎你， Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:\"jack\" }, methods:{ showInfo(e){ console.log(e.target.value) } } }) 常用的按键别名（首字母大写也可使用，实际上大写才是本质，小写是Vue起的别名） enter => 回车 delete => 删除 esc => 退出 space => 空格 tab => 换行，不适用于keyup事件 up => 上 down => 下 left => 左 right => 右 Vue提供别名的按键，可以使用按键原始的key值绑定，但是要转换成kebab-case 可以通过event.key获取名字，event.keycode获取assic码 多个单词组成的所有字母小写，并且单词之间用短横线连接 //通过切换大写的按键触发 Title 欢迎你， Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:\"jack\" }, methods:{ showInfo(e){ console.log(e.target.value) } } }) 系统修饰键（用法特殊）：ctrl/alt/shift/meta 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才能触发 配合keydown使用：可以正常使用 Vue也可以使用keycode指定具体的按键 Vue.config.KeyCodes.自定义按键名 = 键码，可以制定按键别名 🛴修饰符的两个小技巧 修饰符可以连写 案例：阻止事件冒泡+阻止默认事件 Title .demo{ height: 50px; } .div1{ padding: 50px; background-color: aqua; } 欢迎你， 点我提示信息 Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:\"jack\" }, methods:{ showInfo(e){ alert(\"hello\") console.log(e.keyCode) } } }) 键盘key的修饰符可以连写 案例：input只有通过ctrl+y的方式触发事件 Title .demo{ height: 50px; } .div1{ padding: 50px; background-color: aqua; } 欢迎你， Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:\"jack\" }, methods:{ showInfo(e){ alert(\"hello\") console.log(e.keyCode) } } }) 1705 words "},"chapter1/9-计算属性.html":{"url":"chapter1/9-计算属性.html","title":"9. 计算属性","keywords":"","body":"🛴效果 使用v-model的方式实现 Bootstrap 实例 - 基本表单 名称 年龄 -- Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name: \"\", age: \"\", } }) 使用methods方式实现 调用方式{{info()}} Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name: \"\", age: \"\", }, methods:{ info(){ return this.name + '--' + this.age } } }) 使用计算属性实现 定义：所谓计算属性，就是拿一个data中定义的属性去计算，得到一个全新的属性，就是计算属性。 原理：计算属性底层借助了object.defineproperty方法提供的setter和getterget函数执行时机：1.初次读取时会执行一次；2.当依赖的数据发生变化时会再次调用 优势：与methods相比，内部有缓存机制，效率更高 备注：计算属性会出现在vm上，直接读取救会使用，如果计算属性会被修改，则必须实现setter，且setter中对依赖的data中的属性进行赋值，引起data的变化，继而也会引起计算属性调用getter Bootstrap 实例 - 基本表单 名称 年龄 Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name: \"\", age: \"\", }, computed:{ info:{ get(){ //如果有人获取info属性，这个方法就会被调用，返回值是info的值 //调用时机：1.初次读取info时；2.info依赖的属性发生变化时 //如果不是初次读取、依赖的属性没有发生变化，vm中info的值不会再次刷新，其存储在内存中 return this.name + \"--\" + this.age }, set(value){ const arr = value.split(\"--\") this.name = arr[0] this.age = arr[1] } } } }) 计算属性的简写 如果计算属性只需要get但是不需要set的时候，就可以简写 Bootstrap 实例 - 基本表单 名称 年龄 Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name: \"\", age: \"\", }, computed:{ info(){ return this.name + \"--\" + this.age } } }) 895 words "},"chapter1/10-监听属性.html":{"url":"chapter1/10-监听属性.html","title":"10. 监听属性","keywords":"","body":"`🛴效果 Title *{ margin-top: 20px; } .demo{ height: 50px; } .div1{ padding: 50px; background-color: aqua; } 今天天气很 切换天气 Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ isHot: true, }, methods:{ changeStatus(){ this.isHot = !this.isHot } }, computed:{ info(){ return this.isHot ? \"炎热\" : \"凉爽\" } }, watch:{ isHot:{ //可以监视data中定义的属性 immediate: true, //初始化时让handler调用一下 handler(newVal,oldVal){ alert(\"isHot \"+newVal) alert(\"isHot \"+oldVal) } }, info:{//可以监视计算属性 immediate: true, handler(newVal, oldVal) { alert(\"info \"+newVal) alert(\"info \"+oldVal) } } } }) 🛴基本用法总结 当监听的属性变化的时候，回调函数自动调用，并进行相关操作 监视的属性必须存在，才能进行监视，可以监视比如data、computed 监视属性的两种写法 new Vue中用watch配置 通过vm.$watch监视 Title *{ margin-top: 20px; } .demo{ height: 50px; } .div1{ padding: 50px; background-color: aqua; } 今天天气很 切换天气 Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ isHot: true, }, methods:{ changeStatus(){ this.isHot = !this.isHot } }, computed:{ info(){ return this.isHot ? \"炎热\" : \"凉爽\" } }, /* watch:{ isHot:{ //可以监视data中定义的属性 immediate: true, //初始化时让handler调用一下 handler(newVal,oldVal){ alert(\"isHot \"+newVal) alert(\"isHot \"+oldVal) } }, info:{//可以监视计算属性 immediate: true, handler(newVal, oldVal) { alert(\"info \"+newVal) alert(\"info \"+oldVal) } } }*/ }) vm.$watch('info',{ handler(newVal,oldVal){ alert(newVal) alert(oldVal) } }) 深度监视 可以对对象进行深度监视 Title *{ margin-top: 20px; } .demo{ height: 50px; } .div1{ padding: 50px; background-color: aqua; } 今天天气很 切换天气 a的值为 点我修改a的值 a的值为 点我修改b的值 Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ isHot: true, numbers:{ a:1, b:-100, } }, methods:{ changeStatus(){ this.isHot = !this.isHot } }, computed:{ info(){ return this.isHot ? \"炎热\" : \"凉爽\" } }, watch:{ //监视多级结构中属性的变化 'numbers.a':{ immediate: true, handler(n, o) { console.log('a改变了: ',n,o) } }, numbers: { deep:true,//监视多级结构中所有属性的变化 handler(n,o){ console.log('numbers变了') } } } }) vm.$watch('info',{ immediate:true, handler(n,o){ console.log(n,o) } }) 🚩总结 Vue中的watch默认不监视多结构中属性的变化，配置deep=true，可以检测内部值的改变 Vue自身可以监测对象中内部属性的变化，但是Vue提供的watch不行 监视属性的简写形式 Title *{ margin-top: 20px; } .demo{ height: 50px; } .div1{ padding: 50px; background-color: aqua; } 今天天气很 切换天气 a的值为 点我修改a的值 a的值为 点我修改b的值 Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ isHot: true, numbers:{ a:1, b:-100, } }, methods:{ changeStatus(){ this.isHot = !this.isHot } }, computed:{ info(){ return this.isHot ? \"炎热\" : \"凉爽\" } }, watch:{ isHot(newValue,oldValue){ console.log('isHot is changed,',newValue, oldValue) } } }) 1011 words "},"chapter1/11-watchVScomputed.html":{"url":"chapter1/11-watchVScomputed.html","title":"11. watchVScomputed","keywords":"","body":"🛴效果 watch实现 Title *{ margin-top: 20px; } .demo{ height: 50px; } .div1{ padding: 50px; background-color: aqua; } 姓： 名： Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ firstName:\"张\", lastName:\"三\", fullName:\"张——三\" }, methods:{ }, watch:{ firstName(newValue,oldValue){ setTimeout(()=>{ this.fullName = newValue + \"——\" + this.lastName },1000) }, lastName(newValue,oldValue){ setTimeout(()=>{ this.fullName = this.firstName + '——' + this.lastName },1000) } } }) computed实现 Title *{ margin-top: 20px; } .demo{ height: 50px; } .div1{ padding: 50px; background-color: aqua; } 姓： 名： Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ firstName:\"张\", lastName:\"三\", }, methods:{ }, computed:{ fullName(){ return this.firstName + '-' + this.lastName } } }) 等待1s返回需求实现 见watch实现code 计算属性无法实现，因为computed不支持异步请求，它拿的是函数return的结果，这个结果会被缓存。 🚩总结 computed能完成的功能，watch都可以完成 watch能完成的功能，computed不一定能完成，比如异步请求 321 words "},"chapter1/12-绑定样式.html":{"url":"chapter1/12-绑定样式.html","title":"12. 绑定样式","keywords":"","body":"🛴绑定样式的三种写法 Title *{ margin-top: 20px; } .demo{ height: 50px; } .div1{ padding: 50px; background-color: aqua; } .basic{ width: 400px; height: 100px; border: 1px solid black; } .happy{ border: 4px solid red; background: rgb(255, 255, 0,.644) linear-gradient(30deg, yellow, pink, orange, yellow); } .sad{ border: 4px dashed rgb(2,197,2); background-color: gray; } .normal{ background-color: skyblue; } .temp1{ background-color: yellowgreen; } .temp2{ font-size: 30px; text-shadow: 2px 2px 10px red; } .temp3{ border-radius: 20px; } Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:\"jack\", mood:\"normal\", arr:['temp1','temp2','temp3'], classObj:{ temp1:false, temp2:false, temp3:false } }, methods:{ changeMood(){ const arr = ['happy','normal','sad'] const index = Math.floor(Math.random()*3) this.mood = arr[index] }, changeArr(){ if (this.arr.length > 0){ this.arr.shift() } }, changeObj(){ debugger if(this.classObj.temp1){ this.classObj.temp1 = false this.classObj.temp2 = true this.classObj.temp3 = true }else { this.classObj.temp1 = true this.classObj.temp2 = false this.classObj.temp3 = false } } } }) 🛴style的两种写法 对象写法 Title *{ margin-top: 20px; } .demo{ height: 50px; } .div1{ padding: 50px; background-color: aqua; } .basic{ width: 400px; height: 100px; border: 1px solid black; } .happy{ border: 4px solid red; background: rgb(255, 255, 0,.644) linear-gradient(30deg, yellow, pink, orange, yellow); } .sad{ border: 4px dashed rgb(2,197,2); background-color: gray; } .normal{ background-color: skyblue; } .temp1{ background-color: yellowgreen; } .temp2{ font-size: 30px; text-shadow: 2px 2px 10px red; } .temp3{ border-radius: 20px; } Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:\"jack\", styleObj:{ fontSize:\"40px\", color:\"red\", } }, methods:{ } }) 数组写法 Title *{ margin-top: 20px; } .demo{ height: 50px; } .div1{ padding: 50px; background-color: aqua; } .basic{ width: 400px; height: 100px; border: 1px solid black; } .happy{ border: 4px solid red; background: rgb(255, 255, 0,.644) linear-gradient(30deg, yellow, pink, orange, yellow); } .sad{ border: 4px dashed rgb(2,197,2); background-color: gray; } .normal{ background-color: skyblue; } .temp1{ background-color: yellowgreen; } .temp2{ font-size: 30px; text-shadow: 2px 2px 10px red; } .temp3{ border-radius: 20px; } Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:\"jack\", styleArr:[ { fontSize: \"40px\", color:\"red\" }, { backgroundColor: \"orange\" }, ] }, methods:{ } }) 613 words "},"chapter1/13-条件渲染.html":{"url":"chapter1/13-条件渲染.html","title":"13. 条件渲染","keywords":"","body":"🛴v-show Title *{ margin-top: 20px; } .demo{ height: 50px; Title *{ margin-top: 20px; } .demo{ height: 50px; } .div1{ padding: 50px; background-color: aqua; } 点击 点击 Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ isHot: true, }, }) 使用v-show，如果表达式结果为false，则vue会给这个元素一个display属性，此时，这个dom节点仍然可以获取到 v-show不可作用于template v-show比较适合操作比较频繁的场景，因为不会删除dom节点，效率会高一点 🛴v-if Title *{ margin-top: 20px; } .demo{ height: 50px; } .div1{ padding: 50px; background-color: aqua; } 欢迎你， 欢迎你， 当前n为: click me angular React Vue Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:'amir', n: 0, }, }) v-if以及后面的v-if-else、v-else中间不能有其他节点 v-if遵循js的if语句判断逻辑，也就是说v-else-if可能会断路 v-if会如果判断为false，则会删除dom节点，所以不适用于特别频繁的操作 522 words "},"chapter1/14-列表渲染.html":{"url":"chapter1/14-列表渲染.html","title":"14. 列表渲染","keywords":"","body":"🛴遍历数组 Title *{ margin-top: 20px; } .demo{ height: 50px; } .div1{ padding: 50px; background-color: aqua; } name: , age: Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:'jack', n:0, persons:[ {id:'0001',name:\"amir\",age:\"18\"}, {id:'0002',name:\"joker\",age:\"19\"}, {id:'0003',name:\"leo\",age:\"20\"}, ], leo:{ id:\"1001\", name:\"leo\", age:\"100\", } } }) 🛴遍历对象 Title *{ margin-top: 20px; } .demo{ height: 50px; } .div1{ padding: 50px; background-color: aqua; } ------ Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:'jack', n:0, persons:[ {id:'0001',name:\"amir\",age:\"18\"}, {id:'0002',name:\"joker\",age:\"19\"}, {id:'0003',name:\"leo\",age:\"20\"}, ], leo:{ id:\"1001\", name:\"leo\", age:\"100\", } } }) 🛴遍历字符串 Title *{ margin-top: 20px; } .demo{ height: 50px; } .div1{ padding: 50px; background-color: aqua; } --- Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:'jack', n:0, persons:[ {id:'0001',name:\"amir\",age:\"18\"}, {id:'0002',name:\"joker\",age:\"19\"}, {id:'0003',name:\"leo\",age:\"20\"}, ], leo:{ id:\"1001\", name:\"leo\", age:\"100\", } } }) 🛴指定循环次数 Title *{ margin-top: 20px; } .demo{ height: 50px; } .div1{ padding: 50px; background-color: aqua; } --- Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:'jack', n:0, persons:[ {id:'0001',name:\"amir\",age:\"18\"}, {id:'0002',name:\"joker\",age:\"19\"}, {id:'0003',name:\"leo\",age:\"20\"}, ], leo:{ id:\"1001\", name:\"leo\", age:\"100\", } } }) v-for支持可迭代对象的遍历 639 words "},"chapter1/15-key详解.html":{"url":"chapter1/15-key详解.html","title":"15. key详解","keywords":"","body":"🛴一个现象 Title * { padding: 10px; } 点我添加老刘 - Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:'jack', n:0, persons:[ {id:'0001',name:\"amir\",age:\"18\"}, {id:'0002',name:\"joker\",age:\"19\"}, {id:'0003',name:\"leo\",age:\"20\"}, ], leo:{ id:\"1001\", name:\"leo\", age:\"100\", } }, methods:{ Add(){ this.persons.splice(0,0,{id:\"0004\",name:\"laoliu\",age:\"20\"}) } } }) 原理 如果在v-for的时候没有写key，那么vue会把遍历的时候的索引值自动写成key，此时如果破坏顺序，就会产生上图的问题。一般的，这个key最好是唯一标识、从数据库传递过来的数据中指定。 Title * { padding: 10px; } 点我添加老刘 - Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:'jack', n:0, persons:[ {id:'0001',name:\"amir\",age:\"18\"}, {id:'0002',name:\"joker\",age:\"19\"}, {id:'0003',name:\"leo\",age:\"20\"}, ], leo:{ id:\"1001\", name:\"leo\", age:\"100\", } }, methods:{ Add(){ this.persons.splice(0,0,{id:\"0004\",name:\"laoliu\",age:\"20\"}) } } }) 🚩总结 虚拟DOM中key的作用 key是虚拟DOM对象的标识，当数据发生改变时，Vue会根据新的数据生成新的虚拟DOM，随后vue进行新的虚拟DOM和旧的虚拟DOM之间的差异比较（diff算法），规则如下： 在旧的虚拟DOM中找到了与新的虚拟DOM相同的key 如果虚拟DOM的内容没有发生变化，直接使用之前的真实DOM 如果虚拟DOM中内容发生变化，则生成新的真实DOM，随后替换掉之前页面中真实的DOM 如果旧的虚拟DOM中没有找到与新的虚拟DOM相同的key 创建新的真实DOM，随后渲染到页面 用index作为key可能引发的问题 如果对数据进行逆序添加、逆序删除等破坏数据顺序的操作 会产生没有必要的DOM更新，效率低 如果结构中还包含输入类的DOM 会产生错误的DOM更新，界面产生问题 开发中如何选择key 最好使用带有唯一标识的作为key 如果不存在逆序操作等，可以使用index作为key 904 words "},"chapter1/16-列表过滤.html":{"url":"chapter1/16-列表过滤.html","title":"16. 列表过滤","keywords":"","body":"🛴效果 watch实现 Title .root{ width: 500px; height: auto; } 点我添加老刘 search -- Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:'jack', keyword:\"\", n:0, persons:[ {id:'0001',name:\"amir\",age:\"18\"}, {id:'0002',name:\"joker\",age:\"19\"}, {id:'0003',name:\"leo\",age:\"20\"}, ], filterPersons:[], leo:{ id:\"1001\", name:\"leo\", age:\"100\", } }, methods:{ Add(){ this.persons.splice(0,0,{id:\"0004\",name:\"laoliu\",age:\"20\"}) } }, watch:{ keyword: { immediate: true, handler(val){ this.filterPersons = this.persons.filter((p)=>{ return p.name.indexOf(val) !== -1 }) } } } }) computed实现 Title .root{ width: 500px; height: auto; } 点我添加老刘 search -- Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:'jack', keyword:\"\", n:0, persons:[ {id:'0001',name:\"amir\",age:\"18\"}, {id:'0002',name:\"joker\",age:\"19\"}, {id:'0003',name:\"leo\",age:\"20\"}, ], leo:{ id:\"1001\", name:\"leo\", age:\"100\", } }, methods:{ Add(){ this.persons.splice(0,0,{id:\"0004\",name:\"laoliu\",age:\"20\"}) } }, computed:{ filterPersons(){ return this.persons.filter((p)=>{ return p.name.indexOf(this.keyword) !== -1 }) } } }) 603 words "},"chapter1/17-列表排序.html":{"url":"chapter1/17-列表排序.html","title":"17. 列表排序","keywords":"","body":"🛴效果 Title .root{ width: 500px; height: auto; } 年龄升序 年龄降序 原顺序 search -- Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:'jack', keyword:\"\", sortType:0, //0：原顺序，1：降序，2：升序 n:0, persons:[ {id:'0001',name:\"amir\",age:\"30\"}, {id:'0002',name:\"joker\",age:\"19\"}, {id:'0003',name:\"leo\",age:\"21\"}, ], leo:{ id:\"1001\", name:\"leo\", age:\"100\", } }, methods:{ Add(){ this.persons.splice(0,0,{id:\"0004\",name:\"laoliu\",age:\"20\"}) } }, computed:{ filterPersons(){ const arr = this.persons.filter((p)=>{ return p.name.indexOf(this.keyword) !== -1 }) //判断是否需要排序 if(this.sortType){ arr.sort((p1,p2)=>{ return this.sortType === 1 ? p2.age - p1.age : p1.age - p2.age }) } return arr } } }) 369 words "},"chapter1/18-Vue是怎么监视数据改变的.html":{"url":"chapter1/18-Vue是怎么监视数据改变的.html","title":"18. Vue是怎么监视数据改变的","keywords":"","body":"🛴一个现象 需求：通过一个按钮点击事件修改data中一个对象数组的数据 Title .root{ width: 500px; height: auto; } 修改amir数据 -- Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ persons:[ {id:'0001',name:\"amir\",age:\"30\"}, {id:'0002',name:\"joker\",age:\"19\"}, {id:'0003',name:\"leo\",age:\"21\"}, ], }, methods:{ updateAmir(){ this.persons[0].age = 18 //生效的写法 this.persons[0] = {id:'0001',name:\"amir\",age:\"18\"} } //不生效的写法 }, }) 🛴js手动实现对数据的监视 Title let data ={ name:\"amir\", address:\"shenzhen\" } const obs = new Observer(data) let vm = {} vm._data = data = obs function Observer(obj){ const keys = Object.keys(obj) keys.forEach((k)=>{ Object.defineProperty(this,k,{ get() { return obj[k] }, set(val){ console.log(`${k}被改变了`) obj[k] = val } }) }) } vue其实在set中做了很多事情，比如，只要修改值就会重新进行template解析，然后进行diff对比虚拟DOM和真实DOM，最后生成真实DOM，在页面渲染出来 🛴Vue.set()的使用 能否为data中的对象新增一个属性 Title .root{ width: 500px; height: auto; } 学校名称: 学校地址: :&nbsp;&nbsp; Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ Student:{ base:{ name:\"jack\", age:18, address:\"shenzhen\" }, school:\"清华\", schoolAddress:\"北京\" } }, }) 能否直接通过console给Student.base添加一个gender属性并展示在列表中？ 错误的示例 无法通过直接赋值的方式为Student.base添加属性并展示在页面上 正确的示例 使用了Vue.set()函数添加就会成功，因为其检测了数据的变化，就会重新渲染template Vue.set()的局限 Title .root{ width: 500px; height: auto; } 点击添加校长 学校名称: 学校地址: 学校校长: :&nbsp;&nbsp; Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ Student:{ base:{ name:\"jack\", age:18, address:\"shenzhen\" }, school:\"清华\", schoolAddress:\"北京\" } }, methods:{ addLeader(){ //不能给Vue的data直接添加一个响应式的属性，只能给data中对象添加 //[Vue warn]: Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option. Vue.set(this._data,\"leader\",\"leo\") } } }) 🛴Vue监测数组的改变 Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。 示例对数组的修改 使用vue封装的js操作函数 Title .root{ width: 500px; height: auto; } 点击添加校长&nbsp;&nbsp;&nbsp;&nbsp; 点击添加flying 学校名称: 学校地址: 学校校长: :&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ Student:{ base:{ name:\"jack\", age:18, address:\"shenzhen\" }, school:\"清华\", schoolAddress:\"北京\" }, hobbies:[\"reading\",\"dancing\",\"writing\"] }, methods:{ addLeader(){ //不能给Vue的data直接添加一个响应式的属性，只能给data中对象添加 //[Vue warn]: Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option. Vue.set(this._data,\"leader\",\"leo\") }, changeReading(){ this.hobbies.splice(0,0,\"flying\") } } }) 使用Vue.set修改 Title .root{ width: 500px; height: auto; } 点击添加校长&nbsp;&nbsp;&nbsp;&nbsp; 点击修改flying 学校名称: 学校地址: 学校校长: :&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ Student:{ base:{ name:\"jack\", age:18, address:\"shenzhen\" }, school:\"清华\", schoolAddress:\"北京\" }, hobbies:[\"reading\",\"dancing\",\"writing\"] }, methods:{ addLeader(){ //不能给Vue的data直接添加一个响应式的属性，只能给data中对象添加 //[Vue warn]: Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option. Vue.set(this._data,\"leader\",\"leo\") }, changeReading(){ Vue.set(this.hobbies,0,\"flying\") } } }) 强制刷新 Title .root{ width: 500px; height: auto; } 点击添加校长&nbsp;&nbsp;&nbsp;&nbsp; 点击修改flying 学校名称: 学校地址: 学校校长: :&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ Student:{ base:{ name:\"jack\", age:18, address:\"shenzhen\" }, school:\"清华\", schoolAddress:\"北京\" }, hobbies:[\"reading\",\"dancing\",\"writing\"] }, methods:{ addLeader(){ //不能给Vue的data直接添加一个响应式的属性，只能给data中对象添加 //[Vue warn]: Avoid adding reactive properties to a Vue instance or its root $data at runtime - declare it upfront in the data option. Vue.set(this._data,\"leader\",\"leo\") }, changeReading(){ this.hobbies[0] = \"flying\" //实际上数据已经修改了，只需要重新渲染一下 vm.$forceUpdate() } } }) 注意如果数组中存储的是对象类型，这些对象也会被生成setter和getter，此时修改这个对象中的属性如this.hobbies[0].name=\"reading\"会修改成功 2157 words "},"chapter1/19-收集表单数据.html":{"url":"chapter1/19-收集表单数据.html","title":"19. 收集表单数据","keywords":"","body":"🛴示例 Title .root{ width: 500px; height: auto; } 账号 密码 年龄 性别： 男 UserInfo. 女 爱好： 跳舞 游戏 阅读 所属校区 Open this select menu 上海 北京 深圳 其他信息 同意协议 Submit Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ UserInfo:{ email:\"\", password:\"\", age:0, gender:\"\", hobbies: [], city:\"\", otherInfo:\"\", agree:\"\" } }, methods:{ printAll(){ console.log(JSON.stringify(this.UserInfo)) } } }) 565 words "},"chapter1/20-过滤器.html":{"url":"chapter1/20-过滤器.html","title":"20. 过滤器","keywords":"","body":"🛴基本使用 格式化时间--局部过滤器 Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ time: Date.now(), }, //计算属性实现 computed:{ fmtTime(){ return dayjs(this.time).format('YYYY-MM-DD, h:mm:ss a'); } }, methods:{ getFmtTime(){ return dayjs(this.time).format('YYYY-MM-DD, h:mm:ss a'); } }, filters:{ timeFormatter(val,formatter=\"YYYY-MM-DD, h:mm:ss a\"){ return dayjs(val).format(formatter); }, mySlice(val){ return val.slice(0,4) } } }) 过滤器函数的第一个参数一定是绑定的数据 过滤器可以传参，但是会作为过滤器函数的第二个参数 过滤器的执行过程： 先拿到绑定数据的value 作为一个参数调用过滤器函数 拿到函数的返回值，替换DOM中的数据 截取字符串--v-bind中的应用 Title .root{ width: 1000px; height: auto; } Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ msg:\"Hello,World\" }, filters:{ msgSlice(val,len){ return val.slice(0,len) } } }) 全局过滤器 如果一个页面中有多个Vue对象，可以写一个公共的过滤器 Title .root{ width: 1000px; height: auto; } Vue.config.productionTip = false //注意这个一定要写在Vue对象生成之气那 Vue.filter('msgSlice',function (value,len){ return value.slice(0,len) }) const vm = new Vue({ el:\"#root\", data:{ msg:\"Hello,World\" }, }) const vm1 = new Vue({ el:\"#root1\", data:{ msg:\"你好,World\" }, }) 🚀注意 filter只能用在插值语法和v-bind上 648 words "},"chapter1/21-其他内置指令.html":{"url":"chapter1/21-其他内置指令.html","title":"21. 其他内置指令","keywords":"","body":"🛴v-text 获取text中的值，替换掉整个标签里面的内容 他会把所有内容当成文本处理，即使里面有标签，也不会渲染 Title .root{ width: 1000px; height: auto; } Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ msg:\"Hello,World\" }, }) 🛴v-hmtl 支持html结构的解析 但是如果在msg中继续使用插值语法则不会生效 Title .root{ width: 1000px; height: auto; } Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:\"jack\", msg:\"你好，world\" }, }) cookie安全性问题 如果我们在当前页面设置几个未被httpOnly限制的cookie，就可以通过document.cookie获取到这些cookie，存在非常严重的安全性问题。所以一定要在可信的数据上使用v-html Title .root{ width: 1000px; height: auto; } Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:\"jack\", msg:\"你好，worldcookie\" }, }) 🛴v-cloak 先看一个问题 页面中引用的VueJs通过后端接口延迟5s返回 package controller import ( \"github.com/gin-gonic/gin\" \"io/ioutil\" \"net/http\" \"os\" \"time\" ) func GetVue(ctx *gin.Context) { //延迟5s返回 time.Sleep(time.Second*5) //读取文件 path, _ := os.Getwd() str, _ := ioutil.ReadFile(path +\"/static/vue.js\") ctx.String(http.StatusOK,string(str)) } Title .root{ width: 1000px; height: auto; } Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:\"jack\", }, }) 页面上div首先是，就5s左右后端返回js才能正常显示。 使用v-cloak解决这个问题 Title .root{ width: 1000px; height: auto; } [v-cloak]{ display: none; } Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ name:\"jack\", }, }) css首先通过[v-cloak]获取到页面所有具有这个属性的标签设置一个隐藏样式 等待浏览器加载完成vueJS，Vue会重新渲染模板，此时v-cloak属性就会被删除，css设置的样式失效 v-cloak，主要是将未经解析的模板隐藏掉，等解析完成后再渲染到页面上 v-cloak没有值 🛴v-once Title .root{ width: 1000px; height: auto; } n原来的值为： n现在的值为： 点我n+1 Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ n:0, }, }) v-once没有值 v-once修饰的标签，只在初始化的时候动态渲染一次，以后就视为静态内容，不再变化了 🛴v-pre Title .root{ width: 1000px; height: auto; } n原来的值为： n现在的值为： 点我n+1 Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ n:0, }, methods:{ count(){ this.n ++ } } }) vue不会解析v-pre修饰的标签 可以在没有指令语法，没有插值语法的节点使用，可以提高效率 1651 words "},"chapter1/22-自定义指令.html":{"url":"chapter1/22-自定义指令.html","title":"22. 自定义指令","keywords":"","body":"🛴需求 1.自定义一个v-big指令，和v-text指令类似，但会把绑定的数值放大10倍 2.定义一个v-fbind指令，与v-bind指令类似，但是可以让绑定的input元素默认获取焦点 需求1 Title .root{ width: 1000px; height: auto; } n现在的值为： n放大10倍后的值为： 点我n+1 Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ n:0, }, methods:{ count(){ this.n ++ } }, directives:{ //big函数什么时候会被调用 //1.指令与元素初次绑定时；2.指令所在的模板发生解析时会被调用 big(element,binding){ element.innerText = binding.value * 10 } } }) 需求2--错误的写法 Title .root{ width: 1000px; height: auto; } n现在的值为： n放大10倍后的值为： 点我n+1 Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ n:0, }, methods:{ count(){ this.n ++ } }, directives:{ //big函数什么时候会被调用 //1.指令与元素初次绑定时；2.指令所在的模板发生解析时会被调用 big(element,binding){ element.innerText = binding.value * 10 }, fbind(element,binding){ element.value = binding.value element.focus() } } }) 需求2--错误的原因 Title .orange{ background-color: orange; } 点击创建input const btn = document.getElementById(\"btn\") btn.onclick = ()=>{ const input = document.createElement('input') input.type = 'number' input.className = 'orange' input.value = 99 // input.focus() //放在这里无法获取焦点，不是没有执行，而是执行了未生效 document.body.append(input) //放在这里正常执行，符合预期 input.focus() } focus需要在真实的dom节点渲染出来后才能生效 而错误的实现第一次添加首先是绑定数据，然后是渲染页面，fbind在真实的dom渲染之前已经执行完了 需求2--正确的写法 Title .root{ width: 1000px; height: auto; } n现在的值为： n放大10倍后的值为： 点我n+1 Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ n:0, }, methods:{ count(){ this.n ++ } }, directives:{ //big函数什么时候会被调用 //1.指令与元素初次绑定时；2.指令所在的模板发生解析时会被调用 big(element,binding){ element.innerText = binding.value * 10 }, fbind:{ //指令与元素绑定 bind(element,binding){ element.value = binding.value }, //指令所在元素被插入页面时调用 inserted(element,binding){ element.focus() }, //指令所在的元素被页面重新解析时 update(element,binding){ element.value = binding.value element.focus() } } } }) 🛴自定义指令的一些细节 定义全局指令 Title .root{ width: 1000px; height: auto; } 点我n+1 Vue.config.productionTip = false Vue.directive('fbind',{ //指令与元素绑定时调用 bind(element,binding){ element.value = binding.value }, //指令所在元素被插入页面时调用 inserted(element,binding){ element.focus() }, //指令所在的元素被页面重新解析时调用 update(element,binding){ element.value = binding.value element.focus() } }) const vm = new Vue({ el:\"#root\", data:{ n:0, }, methods:{ count(){ this.n ++ } }, }) const vm1 = new Vue({ el:\"#root1\", data:{ n:99, }, }) 注意上面的代码有点问题，focus只能有一个元素，但是全局指令的定义方式是正确的 指令中字母之间应该是短划线且小写 其实所有的指令应该加引号，但是我们往往采用简写方式 Title .root{ width: 1000px; height: auto; } 点我n+1 Vue.config.productionTip = false Vue.directive('fbind-number',{ //指令与元素绑定时调用 bind(element,binding){ element.value = binding.value }, //指令所在元素被插入页面时调用 inserted(element,binding){ element.focus() }, //指令所在的元素被页面重新解析时调用 update(element,binding){ element.value = binding.value element.focus() } }) const vm = new Vue({ el:\"#root\", data:{ n:0, }, methods:{ count(){ this.n ++ } }, }) 指令函数中this是全局对象 Title .root{ width: 1000px; height: auto; } n现在的值为： n放大10倍后的值为： 点我n+1 Vue.config.productionTip = false const vm = new Vue({ el:\"#root\", data:{ n:0, }, methods:{ count(){ this.n ++ } }, directives:{ 'big':function (element,binding) { console.log(this) //window element.innerText = binding.value * 10 }, 'fbind-number':{ //指令与元素绑定时调用 bind(element,binding){ console.log(this) //window element.value = binding.value }, //指令所在元素被插入页面时调用 inserted(element,binding){ console.log(this) //window element.focus() }, //指令所在的元素被页面重新解析时调用 update(element,binding){ console.log(this) //window element.value = binding.value element.focus() } } } }) 1967 words "},"chapter2/0-README.html":{"url":"chapter2/0-README.html","title":"第二章","keywords":"","body":"README 第二章主要研究组件以及组件之间的通信 19 words "},"chapter2/1-Vue生命周期.html":{"url":"chapter2/1-Vue生命周期.html","title":"1. Vue的生命周期","keywords":"","body":"🛴生命周期概念 Title .root{ width: 1000px; height: auto; } Hello,Vue Vue.config.productionTip = false new Vue({ el:\"#root\", data:{ opacity:1, }, //Vue完成模板的解析，并把初始的真实DOM挂载到页面的时候调用 mounted(){ setInterval(()=>{ console.log(\"mounted\") this.opacity -= 0.01 if (this.opacity 像mounted这种在特定的时候由Vue调用的函数就被称为生命周期函数 🚀总结 常用的生命周期钩子 mounted：发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】 beforeDestroy：清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】 关于销毁Vue实例 销毁后借助Vue开发者工具看不到任何信息 销毁后自定义事件会失效，但是原生DOM事件仍然有效 一般不在beforeDestroy中操作数据，因为即便操作数据，也不会触发数据更新流程了 389 words "},"chapter2/2-非单文件组件.html":{"url":"chapter2/2-非单文件组件.html","title":"2. 非单文件组件","keywords":"","body":"🛴对组件的理解 定义：实现应用中局部功能代码和资源的集合。 🛴Vue组件化编程 非单文件组件：一个文件中包含有n个组件 单文件组件：一个文件中包含有1个组件 Title //创建school组件 const school = Vue.extend({ //没有el配置项，因为最终所有组件都会被一个vm管理，由vm决定服务哪个节点 template:` 学校名称： 学校地址： `, data(){ return { schoolName: \"北大\", address:\"北京\" } } }) //创建student组件 const student = Vue.extend({ //没有el配置项，因为最终所有组件都会被一个vm管理，由vm决定服务哪个节点 template:` 学生姓名： 学生年龄： `, data(){ return { studentName: \"jack\", age:100 } } }) const hello = Vue.extend({ template:` 点我提示信息 `, data(){ return { name:\"hello,Vue\" } }, methods: { showInfo(){ alert(this.name) } } }) //全局注册组件 Vue.component('hello',hello) new Vue({ el:\"#root\", //注册组件 components:{ school:school, student:student } }) 🛴基本使用总结 Vue中使用组件的步骤 定义组件 注册组件 使用组件（写组件标签） 怎么定义一个组件 使用Vue.extend(options)创建，其中options和new Vue({})中时传入的几乎一样，区别如下 el不要写，因为最终所有的组件都归一个VM管理，由VM中的el决定使用什么容器 data必须写成函数，这样做是为了避免组件复用时，数据存在引用关系。因为函数有自己的内存空间。 使用template模板字符串的方式编写组件结构 注册组件 局部注册：给new Vue中新增一个component配置项 全局注册：Vue.component('组件名',组件) 组件标签 🛴组件使用的注意事项 关于组件名 本次只记录推荐的写法 school：如果有一个单词，可以全部小写 School：如有有一个单词，也可以使用首字母大写的方式 MySchool：如果有两个单词，可以使用驼峰命名法，但是注意，这种方式只能应用于脚手架 my-school：可以使用短划线连接两个全小写单词 关于组件标签 不要使用Html中内置的标签元素名称作为组件名 如果组件创建的时候使用name配置项，则可以指定在Vue开发者工具中显示的组件名称，不管注册的时候写什么key，Vue开发者工具中显示的是name定义的字符串 组件定义的简写形式 const school = Vue.extend(options)简写成const school = options Title //创建school组件 const school = { //没有el配置项，因为最终所有组件都会被一个vm管理，由vm决定服务哪个节点 template:` 学校名称： 学校地址： `, data(){ return { schoolName: \"北大\", address:\"北京\" } } } //创建student组件 const student = { //没有el配置项，因为最终所有组件都会被一个vm管理，由vm决定服务哪个节点 template:` 学生姓名： 学生年龄： `, data(){ return { studentName: \"jack\", age:100 } } } const hello = { template:` 点我提示信息 `, data(){ return { name:\"hello,Vue\" } }, methods: { showInfo(){ alert(this.name) } } } //全局注册组件 Vue.component('hello',hello) new Vue({ el:\"#root\", //注册组件 components:{ school:school, student:student } }) 🛴组件嵌套 Title //创建student组件 const student = { name:\"student\", //没有el配置项，因为最终所有组件都会被一个vm管理，由vm决定服务哪个节点 template:` 学生姓名： 学生年龄： `, data(){ return { studentName: \"jack\", age:100 } }, } //创建school组件 const school = { name:\"school\", //没有el配置项，因为最终所有组件都会被一个vm管理，由vm决定服务哪个节点 template:` 学校名称： 学校地址： `, data(){ return { schoolName: \"北大\", address:\"北京\" } }, components: { student } } const hello = { template:` 点我提示信息 `, data(){ return { name:\"hello,Vue\" } }, methods: { showInfo(){ alert(this.name) } } } const app = { template:` `, components:{ school,hello } } new Vue({ el:\"#root\", //注册组件 components:{ app } }) 一般写一个app组件管理所有组件 组件嵌套需要注意先后顺序，一定要在组件定义之后写入父组件中 1311 words "},"chapter2/3-vueComponent构造函数.html":{"url":"chapter2/3-vueComponent构造函数.html","title":"3. vueComponent构造函数","keywords":"","body":"🛴组件本质是什么 Title 点我提示信息 //创建school组件 const school = Vue.extend({ //没有el配置项，因为最终所有组件都会被一个vm管理，由vm决定服务哪个节点 template:` 学校名称： 学校地址： `, data(){ return { schoolName: \"北大\", address:\"北京\" } } }) new Vue({ el:\"#root\", //注册组件 components:{ school:school, }, methods:{ showInfo(){ alert(school) } } }) 通过点击按钮发现，school本质上是一个构造函数，既然是构造和函数，调用时就要用new关键词 这个函数不是程序员定义的，而是Vue.extend生成的 当在页面使用组件的时候，Vue解析时就会创建组件的实例对象，即调用new VueComponent(options) 每次调用Vue.extend返回的都是一个全新的VueComponent //Vue.js源码 Vue.extend = function (extendOptions) { //略去影响分析的代码 var Sub = function VueComponent (options) { this._init(options); }; //略去影响分析的代码 return Sub }; this的指向 组件配置中 data函数、methods函数、watch函数、computed函数，他们的this均指向VueComponent对象 new Vue配置中 data函数、methods函数、watch函数、computed函数，他们的this均指向Vue实例对象 VueComponent实例对象，简称VC 可以通过vm.$children查看被vm管理的组件,返回是一个数组 388 words "},"chapter2/4-一个重要的内置关系.html":{"url":"chapter2/4-一个重要的内置关系.html","title":"4. 一个重要的内置关系","keywords":"","body":"🛴原型对象简介 Title //定义一个构造函数 function Demo(){ this.a = 1 this.b = 2 } //创建一个Demo的实例对象 const d = new Demo() console.log(Demo.prototype) //显式原型属性 console.log(d.__proto__) //隐式原型属性 console.log(Demo.prototype === d.__proto__) //true //通过显式原型属性操作原型对象，追加一个c属性，值为99 Demo.prototype.c = 99 console.log(Demo.prototype) console.log(d) Demo.x = 100 console.log(d.c) //99 console.log(d.x) //undefined console.log(d.constructor.x) //100 所有的js对象都会从一个prototype中继承属性和方法 比如d从Demo原型对象中继承和a和b 不能通过给使用Demo.x=100给原型对象添加一个x属性而使d.x的查找顺序符合原型链的查找循序得到预期的结果100 所有的js对象都继承自顶端原型Object的实例 当试图访问一个对象的属性时，它不仅仅在该对象上搜索，还会搜索该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或者达到原型链的最顶端 实例的隐式原型属性永远指向实例缔造者的原型对象 给原型对象添加属性或者函数要使用Demo.prototype.[属性名|函数...] 🛴Vue-VueComponent 重要结论： VueComponent.prototype.__proto__ === Vue.prototype 目的：让vc可以访问Vue原型上的属性、方法 Title 点我提示信息 //向Vue原型上添加一个x属性 Vue.prototype.x = 99 //创建school组件 const school = Vue.extend({ //没有el配置项，因为最终所有组件都会被一个vm管理，由vm决定服务哪个节点 template:` 学校名称： 学校地址： 点击显示X `, data(){ return { schoolName: \"北大\", address:\"北京\" } }, methods: { showX(){ alert(this.x) } } }) const vm= new Vue({ el:\"#root\", //注册组件 components:{ school:school, }, methods:{ showInfo(){ alert(school) } } }) 608 words "},"chapter2/5-单文件组件.html":{"url":"chapter2/5-单文件组件.html","title":"5. 单文件组件","keywords":"","body":"🛴创建一个单文件组件 School组件 学校名称： 学校地址： 点我提示学校名 //组件交互相关的代码 export default { name:\"School\", data(){ return{ schoolName:\"北大\", address:\"北京\" } }, methods:{ showInfo(){ alert(this.schoolName) } } } /*组件的样式*/ .demo{ background-color: orange; } Student组件 姓名： 年龄： 点我提示姓名 //组件交互相关的代码 export default { name:\"Student\", data(){ return{ name:\"jack\", age:\"100\" } }, methods:{ showInfo(){ alert(this.name) } } } /*组件的样式*/ .demo{ background-color: orange; } 使用App组件统一管理 import School from \"./School\"; import Student from \"./Student.Vue\"; export default { name:\"App\", components:{ School, Student } } 使用main.js创建vm import App from \"./App\"; new Vue({ el:'#root', template:``, components:{App}, }) 创建容器 Title 以上代码无法直接运行，因为浏览器对es6语法、Vue的支持问题，这里只是学习Vue的框架规范 300 words "},"chapter2/6-vue脚手架.html":{"url":"chapter2/6-vue脚手架.html","title":"6. vue脚手架","keywords":"","body":"🛴Vue脚手架安装 参考官网 🛴Vue项目结构分析 vue-cli默认使用webpack构建项目 .gitignore git提交代码时忽略的文件 babel.config.js 编写vue会用到es6语法，但是浏览器不一定支持，所以使用这个插件进行将es6转换成es5 package.json 项目的基本配置：名称、版本号 项目的启动配置：script对象中配置启动脚本 项目的依赖配置 eslint代码检查规则配置 ... README.md 项目的基本介绍 src assets 存放静态资源如图片、字体等 components 存放所有的子组件 App.vue 所有子组件的父组件，对子组件进行管理 main.js 项目的入口文件 /*此文件是项目的入口文件*/ //引入vue import Vue from 'vue' //引入app组件，他是所有组件的父组件 import App from './App.vue' //关闭vue的生产提示 Vue.config.productionTip = false //创建vm对象 new Vue({ render: h => h(App), }).$mount('#app') public 存放html页面 index.html：配置el用到的容器 🛴cli的默认配置 使用vue inspect > output.js命令生成一个js文件,此文件包含当前项目的所有vue相关的配置，只用于展示 可以在Vue-cli官网查看脚手架的配置方式。 注意需要在vue项目与package.json同级目录下创建一个vue.config.js文件，该文件采用的是common.js的模块化语法。 这个文件一旦修改，需要重新启动才生效 一个简单的示例 vue.config.js module.exports = { pages: { index: { // page 的入口 entry: 'src/main.js', // 模板来源 template: 'public/index.html', // 在 dist/index.html 的输出 filename: 'index.html', // 当使用 title 选项时， // template 中的 title 标签需要是 title: 'Index Page', // 在这个页面中包含的块，默认情况下会包含 // 提取出来的通用 chunk 和 vendor chunk。 chunks: ['chunk-vendors', 'chunk-common', 'index'] }, }, lintOnSave:false, //关闭语法检查，代码提交之前一定要检查一下，我自己写的时候也会开启，这样比较有条不紊 } 535 words "},"chapter2/7-render配置项.html":{"url":"chapter2/7-render配置项.html","title":"7. render配置项","keywords":"","body":"🛴main.js /*此文件是项目的入口文件*/ //引入vue import Vue from 'vue' //引入app组件，他是所有组件的父组件 import App from './App.vue' //关闭vue的生产提示 Vue.config.productionTip = false //创建vm对象 new Vue({ render: h => h(App), }).$mount('#app') 从上面代码发现，vue-cli创建的项目，使用的是render渲染模板，能否在main.js中使用template呢 使用template替换render /*此文件是项目的入口文件*/ //引入vue import Vue from 'vue' //引入app组件，他是所有组件的父组件 import App from './App.vue' //关闭vue的生产提示 Vue.config.productionTip = false //创建vm对象 new Vue({ template:``, components:{ App } }).$mount('#app') 这时候启动项目访问页面，会发现有一个报错： vue.runtime.esm.js?2b0e:619 [Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build. 以上报错简单说就是我们引用了一个不完整的Vue，所以不支持template，解决方案有两种 使用render函数预编译 使用完整版的Vue 使用完整版的Vue修改main.js 首先看一下node_modules中提供的所有Vue版本 vue/dist vue.common.xxx.js：es6有common.js的模块化方式，这些文件是为common.js做项目模块化准备的 vue.esm.xxx.js：es6有modules模块化方式，这些文件是为这种模块化准备的 vue.runtime.xxx.js：在Vue源码上没有模板解析器，缩小了体积 vue.js：完整的vue源码 项目import的默认的Vue版本在Vue源码的package.json中module定义 使用完全版的Vue对main.js进行改造 /*此文件是项目的入口文件*/ //引入vue import Vue from 'vue/dist/vue' //引入app组件，他是所有组件的父组件 import App from './App.vue' //关闭vue的生产提示 Vue.config.productionTip = false //创建vm对象 new Vue({ template:``, components:{ App } }).$mount('#app') 启动项目发现运行成功，App可以正常展示 那么为什么cli要默认使用esm呢？ 实际上Vue源码包含两个部分：Vue核心和Vue模板解析器 我们使用Vue.js开发的时候没有什么问题，但是项目最终使用webpack打包，它已经把Vue代码翻译成了浏览器可以识别的js文件，此时模板解析器还被打包到项目中是没有必要的，况且这部分占据了Vue源码的1/3。所以Vue官方提供了esm这样的版本。 🛴render函数 /*此文件是项目的入口文件*/ //引入vue import Vue from 'vue' //引入app组件，他是所有组件的父组件 import App from './App.vue' //关闭vue的生产提示 Vue.config.productionTip = false //创建vm对象 new Vue({ render:function (createElement){ return createElement(App) } }).$mount('#app') render函数没有使用到this（实际上它的this是一个proxy对象），所以可以简写成箭头函数的样子 /*此文件是项目的入口文件*/ //引入vue import Vue from 'vue' //引入app组件，他是所有组件的父组件 import App from './App.vue' //关闭vue的生产提示 Vue.config.productionTip = false //创建vm对象 new Vue({ render:createElement=> createElement(App) }).$mount('#app') 817 words "},"chapter2/8-ref属性.html":{"url":"chapter2/8-ref属性.html","title":"8. ref属性","keywords":"","body":"🛴使用Id在vue项目中获取元素 点我输出上方的dom元素 点我输出上方的dom元素 import School from \"./components/School\"; export default { name: 'App', components: { School, }, data(){ return { msg:\"欢迎学习Vue\" } }, methods:{ showH2(){ console.log(document.getElementById('title')) }, showSch(){ console.log(document.getElementById('sch')) } } } #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } 上面的获取方式有两个问题 Vue不推荐直接用js操作DOM元素 vc的获取是真实DOM，但是往往我们想要一个vc对象 🛴ref属性 ref属性被用来给元素或者子组件注册引用信息（id的替代者） 应用在html标签上是真实的DOM元素，应用在组件标签上是组件实例对象vc 点我输出上方的dom元素 点我输出上方的dom元素 import School from \"./components/School\"; export default { name: 'App', components: { School, }, data(){ return { msg:\"欢迎学习Vue\" } }, methods:{ showH2(){ console.log(this.$refs.title) }, showSch(){ console.log(this.$refs.sch) } } } #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } 338 words "},"chapter2/9-props配置项.html":{"url":"chapter2/9-props配置项.html","title":"9. props配置项","keywords":"","body":"🛴为什么要用props 如果一个子组件的数据要动态获取而不是写在data中，props就可以接收父组件传递过来的数据 App.vue import School from \"./components/School\"; import Student from \"@/components/Student\"; export default { name: 'App', components: { School, Student }, } #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } Student.vue 欢迎学习Vue 姓名： 年龄： export default { name: \"Student\", props:['name',\"age\"] } .demo{ background-color: gray; } 🛴props的三种写法 数组--只接收 见上面的代码 对象--限制类型 欢迎学习Vue 姓名： 年龄： export default { name: \"Student\", props:{ name:String, age:Number } } .demo{ background-color: gray; } 上面的代码age要求是数字类型，但是我们之前传的是一个字符串，虽然页面上会正常显示，但是调试工具打开会报错，所以我们需要传递一个数字过来 可以使用v-bind简写的形式传递一个数字过去 import School from \"./components/School\"; import Student from \"@/components/Student\"; export default { name: 'App', components: { School, Student }, } #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } 多个对象的写法--限制类型、限制必要性、指定默认值 欢迎学习Vue 姓名： 年龄： export default { name: \"Student\", props:{ name:{ type:String, required: true }, age:{ type:Number, default:99 } } } .demo{ background-color: gray; } 注意：props的优先级是高于vc的methods的，也就是说如果props中接收了一个add函数，methods中不能定义同样名称的函数了 props中的东西原则上不允许修改，因为有些情况Vue监测到修改会报错，而有些情况Vue检测不到 let obj = {a:1,b:2} obj.a=666，这种修改检测不到 let obj = {a:1,b:2} obj = {x:100,y:200}, 这种修改能监测到，会报错 558 words "},"chapter2/10-mixin.html":{"url":"chapter2/10-mixin.html","title":"10. mixin","keywords":"","body":"🛴Mixin 混合是一种设计模式，可以极大的提高代码的复用性。 如果Vue中两个组件在某个方面（函数或者数据等）一致，就可以使用混合模式提炼代码 mixin.js export const mixin = { data(){ return{ x:1001 } }, methods:{ showInfo(){ console.log(this.name) } }, mounted() { console.log(\"hello,vue\") } } Student.vue 欢迎学习Vue 姓名： 年龄： 点击 点击提示x import {mixin} from \"@/mixin\"; export default { name: \"Student\", props:{ name:{ type:String, required: true }, age:{ type:Number, default:99 } }, mixins:[mixin], methods:{ showX(){ alert(this.x) } }, mounted() { console.log(\"hello,student\") } } .demo{ background-color: gray; } School.vue 学校名称： 学校地址： 点击 import {mixin} from \"@/mixin\"; export default { name: \"School\", data(){ return{ name:\"北大\", address:\"shenzhen\" } }, mixins:[mixin] } .demo{ background-color: gray; } 混合的使用方式 通过es6的语法定义和引入 使用mixins:[mixinName]在vc中注册使用 混合js中可以定义哪些 vc中可以定义的，混合中都可以定义，并且和vc中定义一样 如果vc中和混合中有冲突（重名），则优先使用vc中的 特别的，所有Vue中提供的钩子函数，如果混合中和vc中都有定义，则都会执行 🛴Mixin的全局定义 mixin.js export const mixin = { data(){ return{ x:1001 } }, methods:{ showInfo(){ console.log(this.name) } }, mounted() { console.log(\"hello,vue\") } } export const mixin_another = { data(){ return{ global_x:\"全局混合\" } }, mounted() { console.log(this.global_x) } } main.js /*此文件是项目的入口文件*/ //引入vue import Vue from 'vue' //引入app组件，他是所有组件的父组件 import App from './App.vue' //引入全局混合 import {mixin_another} from \"@/mixin\"; //关闭vue的生产提示 Vue.config.productionTip = false //注册全局混合 Vue.mixin(mixin_another) //创建vm对象 new Vue({ render:createElement=> createElement(App) }).$mount('#app') 全局配置对所有组件都生效（包括Root、App、子组件） 484 words "},"chapter2/11-插件.html":{"url":"chapter2/11-插件.html","title":"11. 插件","keywords":"","body":"🛴定义一个插件 plugins.js export default { install(Vue){ //定义全局过滤器,注意过滤器只能用在插值语法和v-bind上 Vue.filter('mySlice',function (val){ return val.slice(0,4) }) //定义一个全局指令 Vue.directive('fbind',{ //指令与元素成功绑定时 bind(element,binding){ element.value = binding.value }, //指令所在的元素被插入页面时 inserted(element,binding){ element.focus() }, update(element,binding){ element.value = binding.value } }) //定义混入 Vue.mixin ({ data(){ return { plugin_x:100, plugin_y:200 } } }) //给Vue原型增加一个demo方法（vm和vc都能使用原型上的方法） Vue.prototype.Hello = ()=>{ alert(\"你好啊\") } } } main.js /*此文件是项目的入口文件*/ //引入vue import Vue from 'vue' //引入app组件，他是所有组件的父组件 import App from './App.vue' //引入全局混合 import {mixin_another} from \"@/mixin\"; //引入插件 import plugins from \"@/plugins\" //关闭vue的生产提示 Vue.config.productionTip = false //注册全局混合 Vue.mixin(mixin_another) //使用插件 Vue.use(plugins) //创建vm对象 new Vue({ render:createElement=> createElement(App) }).$mount('#app') 此时，插件中定义的过滤器、自定义指令、混入、原型上添加的方法，Vue全局都可以使用 TestPlugins.vue 插件use的时候还可以传入其他参数被插件接收 /*此文件是项目的入口文件*/ //引入vue import Vue from 'vue' //引入app组件，他是所有组件的父组件 import App from './App.vue' //引入全局混合 import {mixin_another} from \"@/mixin\"; //引入插件 import plugins from \"@/plugins\" //关闭vue的生产提示 Vue.config.productionTip = false //注册全局混合 Vue.mixin(mixin_another) //使用插件 Vue.use(plugins,\"hello，vue\") //创建vm对象 new Vue({ render:createElement=> createElement(App) }).$mount('#app') 417 words "},"chapter2/12-style-scope.html":{"url":"chapter2/12-style-scope.html","title":"12. style-scope","keywords":"","body":"🛴scoped的作用 scoped用在style标签上，目的是防止vue中样式的冲突，被scoped修饰的style只能在当前组件生效 演示样式冲突 // TestSoped.vue Hello， world export default { name: \"TestScoped\" } .demo{ background-color: orange; } //Student.vue 欢迎学习Vue 姓名： 年龄： 点击 点击提示x import {mixin} from \"@/mixin\"; export default { name: \"Student\", props:{ name:{ type:String, required: true }, age:{ type:Number, default:99 } }, mixins:[mixin], methods:{ showX(){ alert(this.x) } }, mounted() { console.log(\"hello,student\") } } .demo{ background-color: gray; } //App.vue,注意组件的引入顺序 你好，Vue import School from \"./components/School\"; import Student from \"@/components/Student\"; import TestPlugins from \"@/components/TestPlugins\"; import TestScoped from \"@/components/TestScoped\"; export default { name: 'App', components: { School, Student, TestPlugins, TestScoped }, } #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } 发现最终被demo样式修饰的都会变成orange，这是因为 vue中所有没有加scoped的样式最终都会汇总到一起 后面写的会覆盖前面的 这个先后是组件import的先后，并不是在template标签中组件使用的先后 如果与App.vue中的有冲突，最终会以App.vue中的为准 演示scoped scope本身单词的意思就是局部的 Hello， world export default { name: \"TestScope\" } .demo{ background-color: orange; } 🛴有关less的引入 .demo{ background-color: orange; } 但是vue中没有不能直接使用less，需要安装一个插件：less-loader，less-loader版本更新较快，它对webpack5.x进行了兼容，但是我们使用的是webpack4.x，所以在less-loader要使用7.x版本的会好一点 yarn add less-loader@7 yarn add less 479 words "},"chapter3/0-README.html":{"url":"chapter3/0-README.html","title":"第三章","keywords":"","body":"README 从TodoList案例出发学习全局事件总线和消息的发布订阅以及vue封装的动画效果。 33 words "},"chapter3/2-webStorage.html":{"url":"chapter3/2-webStorage.html","title":"2. webStorage","keywords":"","body":"🛴webStorage 存储内容一般支持5M左右（不同浏览器可能不一样） 浏览器端通过window.sessionStorage和window.localStorage属性来实现本地存储 sessionStorage随着浏览器窗口的关闭而消失 localStorage存储的内容，需要手动删除或者过期后才消失 getItem如果对应key的value获取不到，返回值就是null localStorage Document 测试localStorage 点我存储 点我获取 点我删除 点我删除全部 function addInfo() { const student = { name: 'jack', age: 99 } let userName = \"amir\" localStorage.setItem(\"user\", JSON.stringify(student)) localStorage.setItem(\"userName\", userName) } function getInfo() { console.log(localStorage.getItem('user')) console.log(localStorage.getItem('userName')) } function deleteInfo() { localStorage.removeItem('user') } function clearInfo() { localStorage.clear() } sessionStorage Document 测试sessionStorage 点我存储 点我获取 点我删除 点我删除全部 function addInfo() { const student = { name: 'jack', age: 99 } let userName = \"amir\" sessionStorage.setItem(\"user\", JSON.stringify(student)) sessionStorage.setItem(\"userName\", userName) } function getInfo() { console.log(sessionStorage.getItem('user')) console.log(sessionStorage.getItem('userName')) } function deleteInfo() { sessionStorage.removeItem('user') } function clearInfo() { sessionStorage.clear() } 🛴TodoList本地化存储 使用localStorage存储todos import MyHeader from \"@/components/MyHeader\"; import MyList from \"@/components/MyList\"; import MyFooter from \"@/components/MyFooter\"; export default { name: 'App', components: { MyHeader, MyList, MyFooter }, data(){ return { todos:JSON.parse(localStorage.getItem('todos')) || [] } }, methods:{ //添加一个todo addTodo(todoObj){ this.todos.unshift(todoObj) }, //勾选或者取消勾选todo checkTodo(id){ this.todos.forEach((todo)=>{ if(todo.id === id) todo.done = !todo.done }) }, //删除todo deleteTodo(id){ this.todos = this.todos.filter((todo)=>{ return todo.id !== id }) }, //全选或者全不选 checkAllTodo(done){ this.todos.forEach((todo)=>{ todo.done=done }) }, //清除选中 clearDoneTodos(){ this.todos = this.todos.filter((todo)=>{ return !todo.done }) } }, watch:{ todos:{ deep:true, handler(value){ localStorage.setItem('todos',JSON.stringify(value)) } } } } /*base*/ body { background: #fff; } .btn { display: inline-block; padding: 4px 12px; margin-bottom: 0; font-size: 14px; line-height: 20px; text-align: center; vertical-align: middle; cursor: pointer; box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05); border-radius: 4px; } .btn-danger { color: #fff; background-color: #da4f49; border: 1px solid #bd362f; } .btn-danger:hover { color: #fff; background-color: #bd362f; } .btn:focus { outline: none; } .todo-container { width: 600px; margin: 0 auto; } .todo-container .todo-wrap { padding: 10px; border: 1px solid #ddd; border-radius: 5px; } 617 words "},"chapter3/3-组件自定义事件.html":{"url":"chapter3/3-组件自定义事件.html","title":"3. 组件自定义事件","keywords":"","body":"🛴复习props 通过父组件给子组件传递函数类型的props实现子给父传递数据 App.Vue import School from \"@/components/School\"; export default { name: 'App', components:{ School }, methods:{ getSchoolName(name){ console.log(name) } } } /*base*/ body { background: #fff; } .btn { display: inline-block; padding: 4px 12px; margin-bottom: 0; font-size: 14px; line-height: 20px; text-align: center; vertical-align: middle; cursor: pointer; box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05); border-radius: 4px; } .btn-danger { color: #fff; background-color: #da4f49; border: 1px solid #bd362f; } .btn-danger:hover { color: #fff; background-color: #bd362f; } .btn:focus { outline: none; } .todo-container { width: 600px; margin: 0 auto; } .todo-container .todo-wrap { padding: 10px; border: 1px solid #ddd; border-radius: 5px; } School.vue 欢迎来到： 地址： 点击获取学校名称 export default { name: \"School\", props:['getSchoolName'], data(){ return{ schoolName:\"北大\", address:\"beijing\" } }, methods:{ sendSchoolName(){ this.getSchoolName(this.schoolName) } } } 🛴使用v-on给子组件绑定事件 v-on可以简写成@ App.vue import School from \"@/components/School\"; import Student from \"@/components/Student\"; export default { name: 'App', components:{ School, Student }, methods:{ getSchoolName(name){ console.log(name) }, getStudentName(name){ console.log(name) } } } /*base*/ body { background: #fff; } .btn { display: inline-block; padding: 4px 12px; margin-bottom: 0; font-size: 14px; line-height: 20px; text-align: center; vertical-align: middle; cursor: pointer; box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05); border-radius: 4px; } .btn-danger { color: #fff; background-color: #da4f49; border: 1px solid #bd362f; } .btn-danger:hover { color: #fff; background-color: #bd362f; } .btn:focus { outline: none; } .todo-container { width: 600px; margin: 0 auto; } .todo-container .todo-wrap { padding: 10px; border: 1px solid #ddd; border-radius: 5px; } Student.vue 注意这里获取vc上绑定的事件用$emit 欢迎你，新同学 你的年龄是： 点击发送学生姓名 export default { name: \"Student\", data(){ return{ name:'amir', age:100 } }, methods:{ sendStudentName(){ this.$emit('getSubStudentName',this.name) } } } 🛴使用ref给子组件绑定事件 App.vue import School from \"@/components/School\"; import Student from \"@/components/Student\"; import ClassRoom from \"@/components/ClassRoom\"; export default { name: 'App', components:{ School, Student, ClassRoom }, methods:{ getSchoolName(name){ console.log(name) }, getStudentName(name){ console.log(name) }, getClassRoom(val){ console.log(val) } }, mounted() { //this.$refs.classroom.$once('getClassRoom',this.getClassRoom) //事件只触发一次 //注意这里如果直接写函数而不使用methods的函数，如果是普通函数，this是谁触发这个事件则this是谁，如果使用箭头函数，则this会向上找到当前的app组件实例 this.$refs.classroom.$on('getClassRoom',this.getClassRoom) } } /*base*/ body { background: #fff; } .btn { display: inline-block; padding: 4px 12px; margin-bottom: 0; font-size: 14px; line-height: 20px; text-align: center; vertical-align: middle; cursor: pointer; box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05); border-radius: 4px; } .btn-danger { color: #fff; background-color: #da4f49; border: 1px solid #bd362f; } .btn-danger:hover { color: #fff; background-color: #bd362f; } .btn:focus { outline: none; } .todo-container { width: 600px; margin: 0 auto; } .todo-container .todo-wrap { padding: 10px; border: 1px solid #ddd; border-radius: 5px; } ClassRoom.vue 欢迎来到学习 roomID: 发送教室信息 export default { name: \"ClassRoom\", data(){ return{ classRoom:{ id:\"01-11\", name:\"多媒体教室\" } } }, methods:{ sendClassRoomInfo(){ this.$emit('getClassRoom',JSON.stringify(this.classRoom)) } } } 注意：$ref绑定事件的方式有$on，$once等 自定义事件上也可以加事件修饰符 🛴自定义事件的解绑 使用this.$off()解绑自定义事件 解绑多个：this.$off(['event1','event2']) 解绑一个：this.$off('event1') 全部解绑：this.$off() 也可以使用this.$destory()解绑，不过这个就是销毁vc了 ClassRoom.vue 欢迎来到学习 roomID: 点击提示信息 发送教室信息 发送教室ID 解绑发送教室信息事件 export default { name: \"ClassRoom\", data(){ return{ classRoom:{ id:\"01-11\", name:\"多媒体教室\" } } }, methods:{ showInfo(){ alert(this.classRoom.id) }, sendClassRoomInfo(){ this.$emit('getClassRoom',JSON.stringify(this.classRoom)) }, sendClassRoomID(){ this.$emit('getClassRoomID', this.classRoom.id) }, offBindEvent(){ this.$off('getClassRoom') //解绑单个自定义事件 this.$off(['getClassRoom','getClassRoomID']) //解绑多个自定义事件 this.$off() //解绑所有自定义事件 this.$destroy() //销毁vc,销毁vc并不是销毁真实DOM节点，所以method里面定义的普通事件还是有用的 } }, } 🛴注意事项 $refs绑定的函数 通过this.$refs.xxx.$on(\"event1\",回调)，这个回调函数要么配置到methods中，要么用箭头函数，否则this的指向会出现问题 比如我们要在App.vue中要获取ClassRoom的name 错误的写法 App.vue 教室的名称为： import School from \"@/components/School\"; import Student from \"@/components/Student\"; import ClassRoom from \"@/components/ClassRoom\"; export default { name: 'App', data(){ return { classRoomName: \"\" } }, components:{ School, Student, ClassRoom }, methods:{ getSchoolName(name){ console.log(name) }, getStudentName(name){ console.log(name) }, getClassRoom(val){ console.log(val) }, getClassRoomID(val){ console.log(val) } }, mounted() { // //this.$refs.classroom.$once('getClassRoom',this.getClassRoom) //事件只触发一次 // this.$refs.classroom.$on('getClassRoom',this.getClassRoom) // this.$refs.classroom.$on('getClassRoomID',this.getClassRoomID) this.$refs.classroom.$on('getClassRoomName',function (name){ console.log(this) //classroom vc this.classRoomName = name }) } } /*base*/ body { background: #fff; } .btn { display: inline-block; padding: 4px 12px; margin-bottom: 0; font-size: 14px; line-height: 20px; text-align: center; vertical-align: middle; cursor: pointer; box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05); border-radius: 4px; } .btn-danger { color: #fff; background-color: #da4f49; border: 1px solid #bd362f; } .btn-danger:hover { color: #fff; background-color: #bd362f; } .btn:focus { outline: none; } .todo-container { width: 600px; margin: 0 auto; } .todo-container .todo-wrap { padding: 10px; border: 1px solid #ddd; border-radius: 5px; } ClassRoom.vue 欢迎来到学习 roomID: 点击提示信息 发送教室信息 发送教室ID 解绑发送教室信息事件 发送教室name export default { name: \"ClassRoom\", data(){ return{ classRoom:{ id:\"01-11\", name:\"多媒体教室\" } } }, methods:{ showInfo(){ alert(this.classRoom.id) }, sendClassRoomInfo(){ this.$emit('getClassRoom',JSON.stringify(this.classRoom)) }, sendClassRoomID(){ this.$emit('getClassRoomID', this.classRoom.id) }, offBindEvent(){ this.$off('getClassRoom') //解绑单个自定义事件 this.$off(['getClassRoom','getClassRoomID']) //解绑多个自定义事件 this.$off() //解绑所有自定义事件 this.$destroy() //销毁vc,销毁vc并不是销毁真实DOM节点，所以method里面定义的普通事件还是有用的 }, sendClassRoomName(){ this.$emit('getClassRoomName',this.classRoom.name) } }, } 运行上面代码发现App绑定函数的this居然是classroom的vc，导致无法正常获取数据 正确的写法 App.vue 教室的名称为： import School from \"@/components/School\"; import Student from \"@/components/Student\"; import ClassRoom from \"@/components/ClassRoom\"; export default { name: 'App', data(){ return { classRoomName: \"\" } }, components:{ School, Student, ClassRoom }, methods:{ getSchoolName(name){ console.log(name) }, getStudentName(name){ console.log(name) }, getClassRoom(val){ console.log(val) }, getClassRoomID(val){ console.log(val) } }, mounted() { // //this.$refs.classroom.$once('getClassRoom',this.getClassRoom) //事件只触发一次 // this.$refs.classroom.$on('getClassRoom',this.getClassRoom) // this.$refs.classroom.$on('getClassRoomID',this.getClassRoomID) this.$refs.classroom.$on('getClassRoomName', name=>{ console.log(this) this.classRoomName = name }) } } /*base*/ body { background: #fff; } .btn { display: inline-block; padding: 4px 12px; margin-bottom: 0; font-size: 14px; line-height: 20px; text-align: center; vertical-align: middle; cursor: pointer; box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05); border-radius: 4px; } .btn-danger { color: #fff; background-color: #da4f49; border: 1px solid #bd362f; } .btn-danger:hover { color: #fff; background-color: #bd362f; } .btn:focus { outline: none; } .todo-container { width: 600px; margin: 0 auto; } .todo-container .todo-wrap { padding: 10px; border: 1px solid #ddd; border-radius: 5px; } 上面是写箭头函数，其实也可以把回调函数写在methods中，保证了this的指向正确 能否给组件绑定@click事件 答案是可以，但是这个事件也需要自定义，被当作自定义事件对待 App.vue 教室的名称为： import School from \"@/components/School\"; import Student from \"@/components/Student\"; import ClassRoom from \"@/components/ClassRoom\"; export default { name: 'App', data(){ return { classRoomName: \"\" } }, components:{ School, Student, ClassRoom }, methods:{ getSchoolName(name){ console.log(name) }, getStudentName(name){ console.log(name) }, getClassRoom(val){ console.log(val) }, getClassRoomID(val){ console.log(val) }, clickEvent(){ alert(\"haha\") } }, mounted() { // //this.$refs.classroom.$once('getClassRoom',this.getClassRoom) //事件只触发一次 // this.$refs.classroom.$on('getClassRoom',this.getClassRoom) // this.$refs.classroom.$on('getClassRoomID',this.getClassRoomID) this.$refs.classroom.$on('getClassRoomName', name=>{ console.log(this) this.classRoomName = name }) } } /*base*/ body { background: #fff; } .btn { display: inline-block; padding: 4px 12px; margin-bottom: 0; font-size: 14px; line-height: 20px; text-align: center; vertical-align: middle; cursor: pointer; box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05); border-radius: 4px; } .btn-danger { color: #fff; background-color: #da4f49; border: 1px solid #bd362f; } .btn-danger:hover { color: #fff; background-color: #bd362f; } .btn:focus { outline: none; } .todo-container { width: 600px; margin: 0 auto; } .todo-container .todo-wrap { padding: 10px; border: 1px solid #ddd; border-radius: 5px; } ClassRoom.vue 欢迎来到学习 roomID: 点击提示信息 发送教室信息 发送教室ID 解绑发送教室信息事件 发送教室name 点击提示信息 export default { name: \"ClassRoom\", data(){ return{ classRoom:{ id:\"01-11\", name:\"多媒体教室\" } } }, methods:{ showInfo(){ alert(this.classRoom.id) }, sendClassRoomInfo(){ this.$emit('getClassRoom',JSON.stringify(this.classRoom)) }, sendClassRoomID(){ this.$emit('getClassRoomID', this.classRoom.id) }, offBindEvent(){ this.$off('getClassRoom') //解绑单个自定义事件 this.$off(['getClassRoom','getClassRoomID']) //解绑多个自定义事件 this.$off() //解绑所有自定义事件 this.$destroy() //销毁vc,销毁vc并不是销毁真实DOM节点，所以method里面定义的普通事件还是有用的 }, sendClassRoomName(){ this.$emit('getClassRoomName',this.classRoom.name) }, testClick(){ this.$emit('click') } }, } 能否给组件绑定原生的@click事件 答案是可以，但是要用事件修饰符native，同时，这个事件实际上被绑定到了组件源码的第一个非template元素上 App.vue 教室的名称为： import School from \"@/components/School\"; import Student from \"@/components/Student\"; import ClassRoom from \"@/components/ClassRoom\"; export default { name: 'App', data(){ return { classRoomName: \"\" } }, components:{ School, Student, ClassRoom }, methods:{ getSchoolName(name){ console.log(name) }, getStudentName(name){ console.log(name) }, getClassRoom(val){ console.log(val) }, getClassRoomID(val){ console.log(val) }, clickEvent(){ alert(\"haha\") }, nativeClickEvent(){ alert(\"heihei\") } }, mounted() { // //this.$refs.classroom.$once('getClassRoom',this.getClassRoom) //事件只触发一次 // this.$refs.classroom.$on('getClassRoom',this.getClassRoom) // this.$refs.classroom.$on('getClassRoomID',this.getClassRoomID) this.$refs.classroom.$on('getClassRoomName', name=>{ console.log(this) this.classRoomName = name }) } } /*base*/ body { background: #fff; } .btn { display: inline-block; padding: 4px 12px; margin-bottom: 0; font-size: 14px; line-height: 20px; text-align: center; vertical-align: middle; cursor: pointer; box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05); border-radius: 4px; } .btn-danger { color: #fff; background-color: #da4f49; border: 1px solid #bd362f; } .btn-danger:hover { color: #fff; background-color: #bd362f; } .btn:focus { outline: none; } .todo-container { width: 600px; margin: 0 auto; } .todo-container .todo-wrap { padding: 10px; border: 1px solid #ddd; border-radius: 5px; } 🚀总结 组件的自定义事件 是一种组件间的通信方式，适用于：子组件 ===》父组件，传递数据 使用场景 A是父组件、B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中） 绑定自定义事件的方式 mouted(){this.$refs.SubComponent.$on('eventName',callback)} 如果想要事件只执行一次，则使用$once或者once修饰符 自定义事件的触发：this.$emit('eventName',params) 解绑自定义事件：this.$off('eventName') 组件上也可以绑定原生DOM事件，需要native修饰 注意$refs帮定的自定义事件，要么写在methods中，要么写成箭头函数，否则this指向会有问题 ​ 2778 words "},"chapter3/5-全局事件总线.html":{"url":"chapter3/5-全局事件总线.html","title":"5. 全局事件总线","keywords":"","body":"🛴引入全局数据总线 目前父组件和子组件之间的数据交互我们解决了，子组件获取父组件中的数据可以使用props（可以是函数、基本数据等），子组件给父组件传递数据用自定义事件。但是子组件之间的通信能否解决呢？我们能否定义一个组件专门负责子组件之间的数据交互？ 既然这种构想看起来很不错，怎么实现呢？我们需要创建一个新的vc，这个vc必须全局能使用到，而且包含数据管理、$on、$emit、$off函数。其实我们之前学习过一个重要的内置关系VueComponent.prototype.__proto__ === Vue.prototype，这个vc能加在vue的显示原型上那就解决了问题。好了，既然到这里了直接说答案吧 main.js /*此文件是项目的入口文件*/ //引入vue import Vue from 'vue' //引入app组件，他是所有组件的父组件 import App from './App.vue' //引入全局混合 import {mixin_another} from \"@/mixin\"; //引入插件 import plugins from \"@/plugins\" //关闭vue的生产提示 Vue.config.productionTip = false //注册全局混合 Vue.mixin(mixin_another) //使用插件 Vue.use(plugins,\"hello，vue\") //创建vm对象 new Vue({ render:createElement=> createElement(App), beforeCreate() { Vue.prototype.$bus = this } }).$mount('#app') 查看vm，可以在vm原型上找到$bus 🛴应用场景 父给子：使用props即可 子给父：使用自定义事件 两个没有直接关系的组件：使用全局事件总线。实际上它可以实现任意组件的通信，但是我们在开发过程中编写函数名称是一个很头疼的事情，稍有不慎就冲突了，因此我建议$bus上绑定事件只需要用在两个没有直接关系的组件上即可。当然不同的团队可能对函数定义有自己的一套方案，这个就另说了。 521 words "},"chapter3/6-$bus对TodoList进行改造.html":{"url":"chapter3/6-$bus对TodoList进行改造.html","title":"6. $bus对TodoList进行改造","keywords":"","body":"🛴改造哪个部分 App.vue和MyItem.vue这是两个没有直接关系的组件，我们之前使用props获取数据，props还经过了MyList接收，实现颇为累赘，增加了多余的耦合，所以接下来改造这部分。 App.vue import MyHeader from \"@/components/MyHeader\"; import MyList from \"@/components/MyList\"; import MyFooter from \"@/components/MyFooter\"; export default { name: 'App', components: { MyHeader, MyList, MyFooter }, data(){ return { todos:JSON.parse(localStorage.getItem('todos')) || [] } }, methods:{ //添加一个todo addTodo(todoObj){ this.todos.unshift(todoObj) }, //勾选或者取消勾选todo checkTodo(id){ this.todos.forEach((todo)=>{ if(todo.id === id) todo.done = !todo.done }) }, //删除todo deleteTodo(id){ this.todos = this.todos.filter((todo)=>{ return todo.id !== id }) }, //全选或者全不选 checkAllTodo(done){ this.todos.forEach((todo)=>{ todo.done=done }) }, //清除选中 clearDoneTodos(){ this.todos = this.todos.filter((todo)=>{ return !todo.done }) } }, watch:{ todos:{ deep:true, handler(value){ localStorage.setItem('todos',JSON.stringify(value)) } } }, mounted() { this.$bus.$on(\"checkTodo\",this.checkTodo) this.$bus.$on(\"deleteTodo\",this.deleteTodo) }, beforeDestroy() { this.$bus.$off(['checkTodo','deleteTodo']) } } /*base*/ body { background: #fff; } .btn { display: inline-block; padding: 4px 12px; margin-bottom: 0; font-size: 14px; line-height: 20px; text-align: center; vertical-align: middle; cursor: pointer; box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05); border-radius: 4px; } .btn-danger { color: #fff; background-color: #da4f49; border: 1px solid #bd362f; } .btn-danger:hover { color: #fff; background-color: #bd362f; } .btn:focus { outline: none; } .todo-container { width: 600px; margin: 0 auto; } .todo-container .todo-wrap { padding: 10px; border: 1px solid #ddd; border-radius: 5px; } MyList.vue import MyItem from \"@/components/MyItem\"; export default { name: \"MyList\", components:{ MyItem }, props:['todos'] } /*main*/ .todo-main { margin-left: 0px; border: 1px solid #ddd; border-radius: 2px; padding: 0px; } .todo-empty { height: 40px; line-height: 40px; border: 1px solid #ddd; border-radius: 2px; padding-left: 5px; margin-top: 10px; } MyItem.vue 删除 export default { name: \"MyItem\", props:['todo'], methods:{ handleCheck(id){ //勾选or取消勾选 // this.checkTodo(id) this.$bus.$emit('checkTodo',id) }, handleDelete(id){ //删除 if(confirm(\"确定删除吗？\")){ // this.deleteTodo(id) this.$bus.$emit('deleteTodo',id) } } } } /*item*/ li { list-style: none; height: 36px; line-height: 36px; padding: 0 5px; border-bottom: 1px solid #ddd; } li label { float: left; cursor: pointer; } li label li input { vertical-align: middle; margin-right: 6px; position: relative; top: -1px; } li button { float: right; display: none; margin-top: 3px; } li:before { content: initial; } li:last-child { border-bottom: none; } li:hover { background-color: #ddd; } li:hover button { display: inline-block; } 🚀总结 在编写过程中，发现在什么地方编写绑定事件、什么地方调用事件一直很模糊，所以需要提炼理清 谁需要数据就在谁身上编写绑定事件 绑定事件用$on(eventName,callback) 谁要传递数据就在谁身上调用事件 调用事件用$emit(eventName,params) 特别的，在组件销毁的时候，一定要解绑事件 beforeDestory(){this.$bus.$off(eventName)} 689 words "},"chapter3/7-消息的订阅和发布.html":{"url":"chapter3/7-消息的订阅和发布.html","title":"7. 消息的订阅和发布","keywords":"","body":"🛴什么是消息订阅/发布 消息发布订阅有三个关键角色 发布者：发布某个topic的消息 订阅者：订阅某个topic的消息 消息体：消息体，带有唯一的标识 🛴pubsub.js pubsub.js是一个用js写的消息发布和订阅的库，支持消息的异步发布和同步发布。 安装 yarn add pubsub-js 引入 import pubsub from 'pubsub-js' API 订阅：const token = pubsub.subscribe('topicName',callback) 发布：pubsub.publish('topicName',params) 取消订阅：pubsub.unsubscribe(token) 其他查看官网 注意 最好在beforeDestroy钩子函数中取消订阅 subscribe的回调callback参数为（topicName,params） 🛴TodoList中使用pubsub 使用pubsub改造todolist中的删除功能 首先确定哪个组件需要数据？App组件需要id 然后确定哪个组件提供数据？MyItem组件提供id 注意：引入的第三方库一般写在import前面 App.vue import pubsub from \"pubsub-js\"; import MyHeader from \"@/components/MyHeader\"; import MyList from \"@/components/MyList\"; import MyFooter from \"@/components/MyFooter\"; export default { name: 'App', components: { MyHeader, MyList, MyFooter }, data(){ return { todos:JSON.parse(localStorage.getItem('todos')) || [] } }, methods:{ //添加一个todo addTodo(todoObj){ this.todos.unshift(todoObj) }, //勾选或者取消勾选todo checkTodo(id){ this.todos.forEach((todo)=>{ if(todo.id === id) todo.done = !todo.done }) }, //删除todo deleteTodo(_,id){ console.log(\"app 执行deletetodo\") this.todos = this.todos.filter((todo)=>{ return todo.id !== id }) }, //全选或者全不选 checkAllTodo(done){ this.todos.forEach((todo)=>{ todo.done=done }) }, //清除选中 clearDoneTodos(){ this.todos = this.todos.filter((todo)=>{ return !todo.done }) } }, watch:{ todos:{ deep:true, handler(value){ localStorage.setItem('todos',JSON.stringify(value)) } } }, mounted() { console.log(\"app 执行 mounted\") this.$bus.$on(\"checkTodo\",this.checkTodo) // this.$bus.$on(\"deleteTodo\",this.deleteTodo) this.token = pubsub.subscribe('deleteTodo',this.deleteTodo) }, beforeDestroy() { this.$bus.$off(['checkTodo','deleteTodo']) //取消订阅 pubsub.unsubscribe(this.token) } } /*base*/ body { background: #fff; } .btn { display: inline-block; padding: 4px 12px; margin-bottom: 0; font-size: 14px; line-height: 20px; text-align: center; vertical-align: middle; cursor: pointer; box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05); border-radius: 4px; } .btn-danger { color: #fff; background-color: #da4f49; border: 1px solid #bd362f; } .btn-danger:hover { color: #fff; background-color: #bd362f; } .btn:focus { outline: none; } .todo-container { width: 600px; margin: 0 auto; } .todo-container .todo-wrap { padding: 10px; border: 1px solid #ddd; border-radius: 5px; } MyItem.vue 删除 import pubsub from \"pubsub-js\"; export default { name: \"MyItem\", props:['todo'], methods:{ handleCheck(id){ //勾选or取消勾选 // this.checkTodo(id) this.$bus.$emit('checkTodo',id) }, handleDelete(id){ //删除 if(confirm(\"确定删除吗？\")){ // this.deleteTodo(id) // this.$bus.$emit('deleteTodo',id) pubsub.publish(\"deleteTodo\",id) } } } } /*item*/ li { list-style: none; height: 36px; line-height: 36px; padding: 0 5px; border-bottom: 1px solid #ddd; } li label { float: left; cursor: pointer; } li label li input { vertical-align: middle; margin-right: 6px; position: relative; top: -1px; } li button { float: right; display: none; margin-top: 3px; } li:before { content: initial; } li:last-child { border-bottom: none; } li:hover { background-color: #ddd; } li:hover button { display: inline-block; } 707 words "},"chapter3/8-TodoList编辑功能.html":{"url":"chapter3/8-TodoList编辑功能.html","title":"8. TodoList编辑功能","keywords":"","body":"🛴需求 在删除按钮旁边加一个编辑按钮，点击后title变成input框，自动获取焦点，用户输入失去焦点后更新todo，还原span 为了总结之前学的知识，这里我详细记录一下思路 编辑按钮绑定点击事件 编辑 点击事件 实现点击后span标签隐藏并被input标签覆盖，input出现了则要获取到焦点。 因为要控制标签的显示和隐藏，所以增加一个isEdit属性，这样就可以用v-show控制元素了。 isEdit属性要添加到todo对象上，todo整体又在被App维护，所以需要使用到Vue.$set()函数。 怎么控制焦点获取呢？button和input是两个独立的元素，所以这里要使用到ref帮助获取dom 一个错误的示例 handleEdit(todo){ this.$set(todo,\"isEdit\",true) this.$refs.inputTitle.focus() } 以上代码有几点问题： 我们每次点击编辑都要重新给todo重新添加一个属性，这样虽然没有问题，但是没有必要，如果有这个属性，我们只需要修改即可 焦点获取并没有生效，为什么？因为我们改变了数据，等这个方法结束后，才会进行dom渲染，此时已经获取了焦点的input会被刷新，处理这个问题，Vue提供了$nextTick函数，作用是：当下一次dom渲染出来后，vue会帮我们调用它里面定义的函数 正确的写法 handleEdit(todo){ if(Object.hasOwnProperty.call(todo,\"isEdit\")){ todo.isEdit = true }else{ this.$set(todo,\"isEdit\",true) } this.$nextTick(() => { this.$refs.inputTitle.focus() }) }, 注意$nextTick里面普通函数的this是null，所以写成箭头函数 html的写法 删除 编辑 焦点失去保存数据 对于todo的操作都在App中，所以App中需要一个updateTodo方法并给$bus绑定一个事件供MyItem调用 App.vue import pubsub from \"pubsub-js\"; import MyHeader from \"@/components/MyHeader\"; import MyList from \"@/components/MyList\"; import MyFooter from \"@/components/MyFooter\"; export default { name: 'App', components: { MyHeader, MyList, MyFooter }, data(){ return { todos:JSON.parse(localStorage.getItem('todos')) || [] } }, methods:{ //添加一个todo addTodo(todoObj){ this.todos.unshift(todoObj) }, //勾选或者取消勾选todo checkTodo(id){ this.todos.forEach((todo)=>{ if(todo.id === id) todo.done = !todo.done }) }, //删除todo deleteTodo(_,id){ console.log(\"app 执行deletetodo\") this.todos = this.todos.filter((todo)=>{ return todo.id !== id }) }, //全选或者全不选 checkAllTodo(done){ this.todos.forEach((todo)=>{ todo.done=done }) }, //清除选中 clearDoneTodos(){ this.todos = this.todos.filter((todo)=>{ return !todo.done }) }, //编辑todo updateTodo(id,title){ this.todos.forEach((todo)=>{ if(todo.id === id) todo.title = title }) }, }, watch:{ todos:{ deep:true, handler(value){ localStorage.setItem('todos',JSON.stringify(value)) } } }, mounted() { console.log(\"app 执行 mounted\") this.$bus.$on(\"checkTodo\",this.checkTodo) // this.$bus.$on(\"deleteTodo\",this.deleteTodo) this.token = pubsub.subscribe('deleteTodo',this.deleteTodo) //绑定todo的edit方法 this.$bus.$on('updateTodo',this.updateTodo) }, beforeDestroy() { this.$bus.$off(['checkTodo','deleteTodo']) //取消订阅 pubsub.unsubscribe(this.token) } } /*base*/ body { background: #fff; } .btn { display: inline-block; padding: 4px 12px; margin-bottom: 0; font-size: 14px; line-height: 20px; text-align: center; vertical-align: middle; cursor: pointer; box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05); border-radius: 4px; } .btn-danger { color: #fff; background-color: #da4f49; border: 1px solid #bd362f; } .btn-danger:hover { color: #fff; background-color: #bd362f; } .btn-primary { color: #fff; background-color: skyblue; border: 1px solid #2f7fbd; margin-right: 5px; } .btn-primary:hover { color: #fff; background-color: #2f76bd; } .btn:focus { outline: none; } .todo-container { width: 600px; margin: 0 auto; } .todo-container .todo-wrap { padding: 10px; border: 1px solid #ddd; border-radius: 5px; } 给input绑定@blur 删除 编辑 import pubsub from \"pubsub-js\"; export default { name: \"MyItem\", props:['todo'], methods:{ handleCheck(id){ //勾选or取消勾选 // this.checkTodo(id) this.$bus.$emit('checkTodo',id) }, handleDelete(id){ //删除 if(confirm(\"确定删除吗？\")){ // this.deleteTodo(id) // this.$bus.$emit('deleteTodo',id) pubsub.publish(\"deleteTodo\",id) } }, handleEdit(todo){ if(Object.hasOwnProperty.call(todo,\"isEdit\")){ todo.isEdit = true }else{ this.$set(todo,\"isEdit\",true) } this.$nextTick(() => { this.$refs.inputTitle.focus() }) }, //编辑的时候，失去焦点修改isEdit //因为点击编辑之后，todo上已经有isEdit属性了，所以可以直接使用 todoBlur(todo,e){ if(e.target.value.trim().length === 0) return alert(\"事件名不能为空\") todo.isEdit = false this.$bus.$emit('updateTodo',todo.id,e.target.value) } }, } /*item*/ li { list-style: none; height: 36px; line-height: 36px; padding: 0 5px; border-bottom: 1px solid #ddd; } li label { float: left; cursor: pointer; } li label li input { vertical-align: middle; margin-right: 6px; position: relative; top: -1px; } li button { float: right; display: none; margin-top: 3px; } li:before { content: initial; } li:last-child { border-bottom: none; } li:hover { background-color: #ddd; } li:hover button { display: inline-block; } 1201 words "},"chapter3/9-动画效果.html":{"url":"chapter3/9-动画效果.html","title":"9. 动画效果","keywords":"","body":"🛴CSS3动画 css(Cascading Style Sheets),级联样式表。可以创建动画。 @keyframs规则 @keyframs规则是创建动画 @keyframs规则内指定一个CSS样式和动画将逐步从当前样式更改为新的样式 一个简单的示例 Title @keyframes myfirst { from {background-color: #da4f49} to {background-color: aqua} } @-webkit-keyframes myfirst { from {background-color: red} to {background-color: yellow} } div { animation: myfirst 5s; -webkit-animation: myfirst 5s; } Hello,Vue 🛴在Vue中使用动画 显示隐藏 Hello, Vue export default { name: \"TestAnimation\", data(){ return { isShow: true } } } h1 { background-color: #da4f49; } .v-enter-active { animation: Hello 1s; } .v-leave-active { animation: Hello 1s reverse; } @keyframes Hello { from { transform: translateX(-100%); } to { transform: translateX(0%); } } Vue中使用transition标签包裹一个元素，给其添加动画效果 appear属性表示开始的时候就以动画的方式展现元素 开始动画css样式名称必须写成v-enter-active 结束动画css样式名称必须写成v-leave-active 如果transition中有name属性，这个属性标识了要用到的样式，所以样式的v必须修改成这个name 显示隐藏 Hello, Vue export default { name: \"TestAnimation\", data(){ return { isShow: true } } } h1 { background-color: #da4f49; } .h1Animation-enter-active { animation: Hello 1s; } .h1Animation-leave-active { animation: Hello 1s reverse; } @keyframes Hello { from { transform: translateX(-100%); } to { transform: translateX(0%); } } 376 words "},"chapter3/10-过渡效果.html":{"url":"chapter3/10-过渡效果.html","title":"10. 过渡效果","keywords":"","body":"🛴使用过渡实现 动画效果使用过渡来实现 显示隐藏 Hello, Vue export default { name: \"TestAnimation\", data(){ return { isShow: true } } } h1 { background-color: #da4f49; } .Hello-enter,.Hello-leave-to { transform: translateX(-100%); } .Hello-leave,.Hello-enter-to { transform: translateX(0%); } .Hello-enter-active,.Hello-leave-active{ transition: 1s linear; } 🛴多个元素的过渡 显示隐藏 Hello, Vue Hello, Python export default { name: \"TestAnimation\", data(){ return { isShow: true } } } h1 { background-color: #da4f49; } .Hello-enter,.Hello-leave-to { transform: translateX(-100%); } .Hello-leave,.Hello-enter-to { transform: translateX(0%); } .Hello-enter-active,.Hello-leave-active{ transition: 1s linear; } 多个元素过渡需要使用transition-group 被transition包裹的标签必须使用key作为唯一标识 215 words "},"chapter3/11-vue封装的过渡和动画.html":{"url":"chapter3/11-vue封装的过渡和动画.html","title":"11. vue封装的过渡和动画","keywords":"","body":"🛴总结 作用：在插入、更新或者移除DOM元素时，在合适的时候给元素添加样式类名 图示 样式的写法 进入的效果 .name-enter .name-enter-active .name-enter-to 离开的效果 .name-leave .name-leave-active .name-leave-to 标签的写法 单个元素：[dom] 多个元素：[dom key=value ] 🛴集成第三方动画 选择使用animate.css 安装 yarn add animate.css 导入 import \"animate.css\" 使用 显示隐藏 Hello, Vue Hello, Python import 'animate.css' export default { name: \"TestAnimation\", data(){ return { isShow: true } } } h1 { background-color: #da4f49; } 208 words "},"chapter3/12-vue代理配置.html":{"url":"chapter3/12-vue代理配置.html","title":"12. vue代理配置","keywords":"","body":"🛴axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 安装 yarn add axios 引用 import axios from \"axios\" 基本使用 // 为给定 ID 的 user 创建请求 axios.get('/user?ID=12345') .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); // 上面的请求也可以这样做 axios.get('/user', { params: { ID: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 🛴使用axios编写业务 通过发起一个后端请求，获取学生数据 TestGet.vue 点击获取学生信息 import axios from \"axios\" export default { name: \"TestGet\", methods:{ getStudent(){ axios.get(\"http://localhost:8080/getStudent\").then( response => { console.log(response.data) }, error =>{} ) } } } 后端代码--通过flask实现 默认端口启动5000 个人跟随自己的技术栈写，不必局限于python from flask import Flask app = Flask(__name__) class Student: def __init__(self, name, age): self.name = name self.age = age @app.route('/getStudent') def hello_world(): student = Student('amir', 18) return { \"name\": student.name, \"age\": student.age } if __name__ == '__main__': app.run() 请求中的跨域问题 请求源和服务器保证协议、域名、端口一致就不存在跨域问题，如果三者有一个不一致就无法跨域 解决方案包括：后端处理、jsonp、服务代理，vue-cli就提供了一个代理服务器 vue.config.js module.exports = { pages: { index: { // page 的入口 entry: 'src/main.js', // 模板来源 template: 'public/index.html', // 在 dist/index.html 的输出 filename: 'index.html', // 当使用 title 选项时， // template 中的 title 标签需要是 title: 'Index Page', // 在这个页面中包含的块，默认情况下会包含 // 提取出来的通用 chunk 和 vendor chunk。 chunks: ['chunk-vendors', 'chunk-common', 'index'] }, }, lintOnSave:false, //关闭语法检查，代码提交之前一定要检查一下 //开启代理服务器 devServer:{ proxy: \"http://localhost:5000\" } } 原理：我们前端代码中给这个代理服务器发送请求，然后它会把请求转发给后端。值得注意的是： 这个代理服务器的端口与vue项目的端口一致，因此我们的axios.get的url端口号是8080 发送的请求首先会在public目录下查找，如果正好匹配到了，就不会走后端了，直接返回 还有一种配置能解决向多个后端服务器发送请求 module.exports = { pages: { index: { // page 的入口 entry: 'src/main.js', // 模板来源 template: 'public/index.html', // 在 dist/index.html 的输出 filename: 'index.html', // 当使用 title 选项时， // template 中的 title 标签需要是 title: 'Index Page', // 在这个页面中包含的块，默认情况下会包含 // 提取出来的通用 chunk 和 vendor chunk。 chunks: ['chunk-vendors', 'chunk-common', 'index'] }, }, lintOnSave:false, //关闭语法检查，代码提交之前一定要检查一下 //开启代理服务器 /* devServer:{ proxy: \"http://localhost:5000\" }*/ devServer: { proxy: { '/api': { target: 'http://localhost:5000', ws: true, //支持socket //修改请求源，设置为true，则后端认为是从5000端口发出的请求，设置为false，则后端认为是从当前服务的端口发送的请求 changeOrigin: true, //修改请求路径 pathRewrite: { '^/api': '' //需要rewrite的, } }, } } } 注意：修改vue.config.js后，项目重启才能生效 786 words "},"chapter3/13-一个get请求案例.html":{"url":"chapter3/13-一个get请求案例.html","title":"13. 一个get请求案例","keywords":"","body":"🛴学习目标 axios发起get请求，以及请求后response的处理 复习组件间的通信技术 实现loading加载的效果 🛴编写过程 组件拆分 App.vue List.vue Search.vue 数据安排 List.vue：存储列表数据 Search：提供查询关键词 方法 Search.vue：点击查询发起ajax请求，然后通过全局总线调用List绑定的函数，把数据传递给List List.vue：负责数据渲染，向全局总线绑定一个函数，供Search调用 coding App.vue import Search from \"@/components/Search\"; import List from \"@/components/List\"; export default { name: 'App', components:{ Search, List } } Search.vue Search Github Users &nbsp; Search import axios from \"axios\"; export default { name: \"Search\", data(){ return { keyword:\"\", } }, methods:{ getUsers(){ //请求前更新list数据 this.$bus.$emit('updateListData',{isLoading:true,errMsg:'',users:[],isFirst:false}) if(!this.keyword.trim()) { return alert(\"请输入查新条件\") } axios.get(`https://api.github.com/search/users?q=${this.keyword}`).then( response=>{ this.$bus.$emit('updateListData',{isLoading:false,errMsg:'',users:response.data.items}) }, error=> { //请求错误更新list this.$bus.$emit('updateListData', {isLoading: false, errMsg: error.message, users: []}) } ) } } } List.vue 欢迎使用 加载中 export default { name: \"List\", data(){ return { info:{ isFirst:true, isLoading:false, errMsg:\"\", users:[] } } }, mounted() { this.$bus.$on('updateListData',(dataObj)=>{ this.info = {...this.info,...dataObj} }) } } .album { min-height: 50rem; /* Can be removed; just added for demo purposes */ padding-top: 3rem; padding-bottom: 3rem; background-color: #f7f7f7; } .card { float: left; width: 33.333%; padding: .75rem; margin-bottom: 2rem; border: 1px solid #efefef; text-align: center; } .card > img { margin-bottom: .75rem; border-radius: 100px; } .card-text { font-size: 85%; } 需要注意的是：在public下的index.html中引入了bootstrap.css index.html favicon.ico\"> css/bootstrap.css\"> We're sorry but doesn't work properly without JavaScript enabled. Please enable it to continue. 642 words "},"chapter3/14-插槽.html":{"url":"chapter3/14-插槽.html","title":"14. 插槽","keywords":"","body":"🛴插槽简介 如果父组件需要给子组件传递一段html结构，就会使用到插槽技术，它是组件间通信的一种方式。 分类：默认插槽、具名插槽、作用域插槽 默认插槽 App.vue Html结构 import TestSlot from \"@/components/TestSlot\"; export default { name: 'App', components:{ TestSlot } } TestSlot.vue 欢迎使用Vue export default { name: \"TestSlot\" } 具名插槽 App.vue Html结构 v-slot,只能在component和template标签上使用 import TestSlot from \"@/components/TestSlot\"; export default { name: 'App', components:{ TestSlot } } TestSlot.vue 欢迎使用Vue 没有匹配上就是显示这些文本 export default { name: \"TestSlot\" } 作用域插槽 数据在组件自生，但根据数据生成的结构需要组件的使用者来决定。（数据在TestSlot,但结构由App决定） App.vue [object Object] import TestSlot from \"@/components/TestSlot\"; export default { name: 'App', components:{ TestSlot } } TestSlot.vue 欢迎使用Vue 没有匹配上就是显示这些文本 export default { name: \"TestSlot\", data(){ return { books:['流畅的python',\"Java编程思想\",\"红房子\"], games:['lol','DNF','CF'] } } } 398 words "},"chapter4/0-README.html":{"url":"chapter4/0-README.html","title":"第四章","keywords":"","body":"README 第四章主要学习vuex和vue-router 12 words "},"chapter4/2-mapState、mapGetters、mapActions、mapMutations.html":{"url":"chapter4/2-mapState、mapGetters、mapActions、mapMutations.html","title":"2. mapState、mapGetters、mapActions、mapMutations","keywords":"","body":"🛴mapState 如果state中有多个属性一个组件需要使用，插值语法原则上不能写的过于复杂，如果用计算属性的方式写，会产生大量的功能一致的类似的代码，这时mapState就可以用来简化写法了 计算属性的写法 index.js import Vue from \"vue\"; import Vuex from \"vuex\"; Vue.use(Vuex) //响应组件中的动作 const actions = { add(context,value){ context.commit('ADD',value) }, sub(context,value){ context.commit('SUB',value) }, addIfOdd(context,value){ context.commit('ADD',value) } } //操作数据 const mutations = { ADD(state,value){ state.sum += value }, SUB(state,value){ state.sum -= value }, } //存储惧 const state = { sum: 0, book:\"golang高级编程\", game:\"God of War:Ⅴ\" } //加工数据 const getters = { bigSum(state){ return state.sum * 10 } } export default new Vuex.Store({ actions, mutations, state, getters }) Count.vue 当前求和为： 当前求和放大10倍为： [object Object] 1 2 3 + - 当前和为奇数的时候再加 等一等再加 import {mapState} from 'vuex' export default { name: \"Count\", data(){ return{ n: 1, } }, computed:{ book(){ return this.$store.state.book }, game(){ return this.$store.state.game }, }, methods:{ increment(){ this.$store.dispatch('add',this.n) }, decrement(){ this.$store.dispatch('sub',this.n) }, incrementOdd(){ if(this.$store.state.sum % 2){ this.$store.dispatch('addIfOdd',this.n) } }, incrementWait(){ setTimeout(()=>{ this.$store.dispatch('add',this.n) },500) } }, } button{ margin-left: 10px; } 使用mapState 当前求和为： 当前求和放大10倍为： [object Object] 1 2 3 + - 当前和为奇数的时候再加 等一等再加 import {mapState} from 'vuex' export default { name: \"Count\", data(){ return{ n: 1, } }, computed:{ // book(){ // return this.$store.state.book // }, // game(){ // return this.$store.state.game // }, //对象写法 ...mapState({book:'book',game:'game'}), //数组写法 ...mapState(['book','game']) }, methods:{ increment(){ this.$store.dispatch('add',this.n) }, decrement(){ this.$store.dispatch('sub',this.n) }, incrementOdd(){ if(this.$store.state.sum % 2){ this.$store.dispatch('addIfOdd',this.n) } }, incrementWait(){ setTimeout(()=>{ this.$store.dispatch('add',this.n) },500) } }, } button{ margin-left: 10px; } 🛴mapGetters 用法与mapState一致 当前求和为： 当前求和放大10倍为： [object Object] 1 2 3 + - 当前和为奇数的时候再加 等一等再加 import {mapState,mapGetters} from 'vuex' export default { name: \"Count\", data(){ return{ n: 1, } }, computed:{ // book(){ // return this.$store.state.book // }, // game(){ // return this.$store.state.game // }, //对象写法 ...mapState({sum:'sum',book:'book',game:'game'}), //数组写法 ...mapState(['sum','book','game']), ...mapGetters(['bigSum']) }, methods:{ increment(){ this.$store.dispatch('add',this.n) }, decrement(){ this.$store.dispatch('sub',this.n) }, incrementOdd(){ if(this.$store.state.sum % 2){ this.$store.dispatch('addIfOdd',this.n) } }, incrementWait(){ setTimeout(()=>{ this.$store.dispatch('add',this.n) },500) } }, } button{ margin-left: 10px; } 🛴mapMutations 如果在组件中直接commit数据而跳过actions，就可以使用mapMutations简化函数的写法 index.js import Vue from \"vue\"; import Vuex from \"vuex\"; Vue.use(Vuex) //响应组件中的动作 const actions = { add(context,value){ context.commit('ADD',value) }, sub(context,value){ context.commit('SUB',value) }, addIfOdd(context,value){ context.commit('ADD',value) } } //操作数据 const mutations = { ADD(state,value){ state.sum += value }, SUB(state,value){ state.sum -= value }, MULTIPLICATION(state,value){ console.log(value) state.sum *= value }, DIVISION(state,value){ state.sum /= value } } //存储惧 const state = { sum: 0, book:\"golang高级编程\", game:\"God of War:Ⅴ\" } //加工数据 const getters = { bigSum(state){ return state.sum * 10 } } export default new Vuex.Store({ actions, mutations, state, getters }) Count.vue 当前求和为： 当前求和放大10倍为： [object Object] 1 2 3 + - * / 当前和为奇数的时候再加 等一等再加 import {mapState,mapGetters,mapMutations} from 'vuex' export default { name: \"Count\", data(){ return{ n: 1, } }, computed:{ // book(){ // return this.$store.state.book // }, // game(){ // return this.$store.state.game // }, //对象写法 ...mapState({sum:'sum',book:'book',game:'game'}), //数组写法 ...mapState(['sum','book','game']), ...mapGetters(['bigSum']) }, methods:{ increment(){ this.$store.dispatch('add',this.n) }, decrement(){ this.$store.dispatch('sub',this.n) }, incrementOdd(){ if(this.$store.state.sum % 2){ this.$store.dispatch('addIfOdd',this.n) } }, incrementWait(){ setTimeout(()=>{ this.$store.dispatch('add',this.n) },500) }, //使用mapMutations生成方法，commit value //注意@click不传参默认传递的是event，传参的话才是n ...mapMutations({multiplication:'MULTIPLICATION',division:'DIVISION'}) }, } button{ margin-left: 10px; } 🛴mapActions 使用mapActions时会自动生成dispatch，但是这时候之前写的奇数判断和延时逻辑在组件中存在就不合适了，所以这部分需要挪到index.js中 index.js import Vue from \"vue\"; import Vuex from \"vuex\"; Vue.use(Vuex) //响应组件中的动作 const actions = { add(context,value){ context.commit('ADD',value) }, sub(context,value){ context.commit('SUB',value) }, addIfOdd(context,value){ context.commit('ADD',value) }, incrementOdd(context,value){ if(context.state.sum % 2){ context.state.sum += value } }, incrementWait(context,value){ setTimeout(()=>{ context.state.sum += value }) }, } //操作数据 const mutations = { ADD(state,value){ state.sum += value }, SUB(state,value){ state.sum -= value }, MULTIPLICATION(state,value){ console.log(value) state.sum *= value }, DIVISION(state,value){ state.sum /= value } } //存储惧 const state = { sum: 0, book:\"golang高级编程\", game:\"God of War:Ⅴ\" } //加工数据 const getters = { bigSum(state){ return state.sum * 10 } } export default new Vuex.Store({ actions, mutations, state, getters }) Count.vue 当前求和为： 当前求和放大10倍为： [object Object] 1 2 3 + - * / 当前和为奇数的时候再加 等一等再加 import {mapState,mapGetters,mapMutations,mapActions} from 'vuex' export default { name: \"Count\", data(){ return{ n: 1, } }, computed:{ // book(){ // return this.$store.state.book // }, // game(){ // return this.$store.state.game // }, //对象写法 ...mapState({sum:'sum',book:'book',game:'game'}), //数组写法 ...mapState(['sum','book','game']), ...mapGetters(['bigSum']) }, methods:{ increment(){ this.$store.dispatch('add',this.n) }, decrement(){ this.$store.dispatch('sub',this.n) }, incrementOdd(){ this.$store.dispatch('incrementOdd',this.n) }, incrementWait(){ this.$store.dispatch('incrementWait',this.n) }, //使用mapActions生成dispatch相关的方法 ...mapActions(['incrementOdd','incrementWait']), ...mapActions({increment:'add', decrement:'sub'}), //使用mapMutations生成方法，commit value //注意@click不传参默认传递的是event，传参的话才是n ...mapMutations({multiplication:'MULTIPLICATION',division:'DIVISION'}) }, } button{ margin-left: 10px; } 1517 words "},"chapter4/3-多组件数据共享.html":{"url":"chapter4/3-多组件数据共享.html","title":"3. 多组件数据共享","keywords":"","body":"🛴需求 Count.vue下面再写一个Person组件，存放用户信息，有一个输入框，输入信息后点击保存按钮可以向personList中添加数据。 Count.vue和Persons.vue的sum和personList数据共享 index.js import Vue from \"vue\"; import Vuex from \"vuex\"; Vue.use(Vuex) //响应组件中的动作 const actions = { add(context,value){ context.commit('ADD',value) }, sub(context,value){ context.commit('SUB',value) }, addIfOdd(context,value){ context.commit('ADD',value) }, incrementOdd(context,value){ if(context.state.sum % 2){ context.state.sum += value } }, incrementWait(context,value){ setTimeout(()=>{ context.state.sum += value }) }, } //操作数据 const mutations = { ADD(state,value){ state.sum += value }, SUB(state,value){ state.sum -= value }, MULTIPLICATION(state,value){ console.log(value) state.sum *= value }, DIVISION(state,value){ state.sum /= value }, addPerson(state,value){ state.personList.push(value) } } //存储惧 const state = { sum: 0, book:\"golang高级编程\", game:\"God of War:Ⅴ\", personList:[] } //加工数据 const getters = { bigSum(state){ return state.sum * 10 } } export default new Vuex.Store({ actions, mutations, state, getters }) Count.vue 当前求和为： 当前求和放大10倍为： Persons组件的人数为： [object Object] 1 2 3 + - * / 当前和为奇数的时候再加 等一等再加 import {mapState,mapGetters,mapMutations,mapActions} from 'vuex' export default { name: \"Count\", data(){ return{ n: 1, } }, computed:{ // book(){ // return this.$store.state.book // }, // game(){ // return this.$store.state.game // }, //对象写法 ...mapState({sum:'sum',book:'book',game:'game'}), //数组写法 ...mapState(['sum','book','game','personList']), ...mapGetters(['bigSum']) }, methods:{ increment(){ this.$store.dispatch('add',this.n) }, decrement(){ this.$store.dispatch('sub',this.n) }, incrementOdd(){ this.$store.dispatch('incrementOdd',this.n) }, incrementWait(){ this.$store.dispatch('incrementWait',this.n) }, //使用mapActions生成dispatch相关的方法 ...mapActions(['incrementOdd','incrementWait']), ...mapActions({increment:'add', decrement:'sub'}), //使用mapMutations生成方法，commit value //注意@click不传参默认传递的是event，传参的话才是n ...mapMutations({multiplication:'MULTIPLICATION',division:'DIVISION'}) }, } button{ margin-left: 10px; } Persons.vue Count组件的计算的sum为： 添加用户 import {nanoid} from \"nanoid\" import {mapState} from \"vuex\"; export default { name: \"Persons\", data(){ return { name:'', } }, computed:{ ...mapState(['personList',\"sum\"]), }, methods:{ addPerson(){ let person = {id:nanoid(),name:this.name} this.$store.commit('addPerson',person) this.name = '' }, }, } 548 words "},"chapter4/4-vuex模块化.html":{"url":"chapter4/4-vuex模块化.html","title":"4. vuex模块化","keywords":"","body":"🛴模块化的作用 与所有模块化基本功能一样，vuex的模块化就是为了解决，变量、函数、对象等名字的冲突或者全局变量被污染的问题，模块化也可以使代码易于编写和维护 🛴修改3的项目 store/personCount.js import {nanoid} from \"nanoid\"; import axios from \"axios\"; export default { namespaced: true, actions:{ addRandomPerson(context){ axios.get('http://localhost:8080/api/getUserName').then( response => { const person = {id:nanoid(),name:response.data.username} console.log(person) context.commit('addPerson',person) }, error =>{ alert(\"获取用户名称err: \"+error.message) } ) } }, mutations:{ addPerson(state,value){ state.personList.push(value) } }, state:{ personList:[] }, getters:{ } } src/countAbout.js export default { namespaced:true, actions:{ add(context,value){ context.commit('ADD',value) }, sub(context,value){ context.commit('SUB',value) }, addIfOdd(context,value){ context.commit('ADD',value) }, incrementOdd(context,value){ if(context.state.sum % 2){ context.state.sum += value } }, incrementWait(context,value){ setTimeout(()=>{ context.state.sum += value }) }, }, mutations:{ ADD(state,value){ state.sum += value }, SUB(state,value){ state.sum -= value }, MULTIPLICATION(state,value){ console.log(value) state.sum *= value }, DIVISION(state,value){ state.sum /= value }, }, state:{ sum: 0, book:\"golang高级编程\", game:\"God of War:Ⅴ\", }, getters:{ bigSum(state){ return state.sum * 10 } } } src/index.js import Vue from \"vue\"; import Vuex from \"vuex\"; import countAbout from \"@/store/countAbout\"; import personAbout from \"@/store/personAbout\"; Vue.use(Vuex) export default new Vuex.Store({ modules:{ countAbout, personAbout } }) Count.vue 当前求和为： 当前求和放大10倍为： Persons组件的人数为： [object Object] 1 2 3 + - * / 当前和为奇数的时候再加 等一等再加 import {mapState,mapGetters,mapMutations,mapActions} from 'vuex' export default { name: \"Count\", data(){ return{ n: 1, } }, computed:{ //对象写法 ...mapState('countAbout',{sum:'sum',book:'book',game:'game'}), //数组写法 ...mapState('countAbout',['sum','book','game',]), ...mapState('personAbout',['personList',]), ...mapGetters('countAbout',['bigSum']) }, methods:{ //使用mapActions生成dispatch相关的方法 ...mapActions('countAbout',['incrementOdd','incrementWait']), ...mapActions('countAbout',{increment:'add', decrement:'sub'}), //使用mapMutations生成方法，commit value //注意@click不传参默认传递的是event，传参的话才是n ...mapMutations('countAbout',{multiplication:'MULTIPLICATION',division:'DIVISION'}) }, } button{ margin-left: 10px; } Person.vue Count组件的计算的sum为： 添加用户 添加随机用户 import {nanoid} from \"nanoid\" export default { name: \"Persons\", data(){ return { name:'', } }, computed:{ personList(){ return this.$store.state.personAbout.personList }, sum(){ return this.$store.state.countAbout.sum } }, methods:{ addPerson(){ let person = {id:nanoid(),name:this.name} this.$store.commit('personAbout/addPerson',person) this.name = '' }, addRandomPerson(){ this.$store.dispatch('personAbout/addRandomPerson') } }, } 🛴axios请求问题 调试过程中发现，如果axios请求的url写成127.0.0.1则请求可以正常发送到后端服务器，但是接收返回值一直是network err,最后写成localhost才解决问题，具体原因未知。 685 words "},"chapter4/5-路由的简介.html":{"url":"chapter4/5-路由的简介.html","title":"5. 路由的简介","keywords":"","body":"🛴路由 路由（route）就是一组key-value的对应关系 多个路由，需要经过路由器（router）的管理 vue-router专门针对单页面应用（SPA）提供路由支持 🛴vue中使用路由 安装 yarn add vue-router 配置路由 src下新建一个router文件夹，并创建一个index.js,这里配置所有的路由信息 main.js中引入配置路由 index.js //该文件专门用于创建应用的路由器 import VueRouter from \"vue-router\" import About from \"@/pages/About\"; import Home from \"@/pages/Home\"; //创建一个路由器 export default new VueRouter({ routes:[ { path:'/about', component:About }, { path:'/home', component:Home }, ] }) main.js /*此文件是项目的入口文件*/ //引入vue import Vue from 'vue' //引入app组件，他是所有组件的父组件 import App from './App.vue' //引入vue-router import VueRouter from \"vue-router\"; //引入路由器 import router from \"./router/index\" //关闭vue的生产提示 Vue.config.productionTip = false Vue.use(VueRouter) //创建vm对象 const vm = new Vue({ render:createElement=> createElement(App), router:router, beforeCreate() { Vue.prototype.$bus = this } }).$mount('#app') console.log(vm) 编写页面 App.vue About Home--> About Home import Banner from \"@/components/Banner\"; export default { name: 'App', components:{ Banner }, } /*base*/ body { background: #fff; } About.vue 我是About的内容 export default { name: \"About\" } Home.vue 我是Home的内容 export default { name: \"Home\" } Banner.vue Vue Router Demo export default { name: \"Banner\" } 注意，以上的vue组件分为两种，一种是router组件，一种是普通组件，开发中，一般路由组件放在pages文件夹下，普通组件放在components文件夹下 public/home.html Vue App Vue Router Demo About Home 我是Home的内容 public/about.html Vue App Vue Router Demo About Home 我是About的内容 🚀总结 传统路由切换的a标签被router-link代替 在router/index.js中注册的路由，可以通过router-view标签自动注入到组件中 路由切换后，原路由的组件被销毁了，可以通过钩子函数查看 844 words "},"chapter4/6-嵌套路由.html":{"url":"chapter4/6-嵌套路由.html","title":"6. 嵌套路由","keywords":"","body":"🛴嵌套路由实现 router/index.js //该文件专门用于创建应用的路由器 import VueRouter from \"vue-router\" import About from \"@/pages/About\"; import Home from \"@/pages/Home\"; import News from \"@/pages/news\"; import Message from \"@/pages/messages\"; import Detail from \"@/pages/Detail\"; //创建一个路由器 export default new VueRouter({ routes:[ { path:'/about', component:About, }, { path:'/home', component:Home, children:[ { path:'news', component:News }, { path:'message', component:Message, children:[ { path:'detail', component:Detail } ] } ] }, ] }) Home.vue Home组件内容 News Message export default { name: \"Home\" } Messages.vue &nbsp;&nbsp; export default { name: \"messages\", data(){ return { messageList:[ {id:\"001\",title:\"消息001\"}, {id:\"002\",title:\"消息002\"}, {id:\"003\",title:\"消息003\"}, ] } } } News.vue news001 news002 news003 export default { name: \"news\" } Details.vue 消息编号： 消息标题： export default { name: \"Detail\" } 🛴 具名路由 给路由起一个名字，当路由过长的时候可以用name属性指定跳转地址 router/index.js //该文件专门用于创建应用的路由器 import VueRouter from \"vue-router\" import About from \"@/pages/About\"; import Home from \"@/pages/Home\"; import News from \"@/pages/News\"; import Message from \"@/pages/Messages\"; import Detail from \"@/pages/Detail\"; //创建一个路由器 export default new VueRouter({ routes:[ { name:\"about\", path:'/about', component:About, }, { path:'/home', component:Home, children:[ { path:'news', component:News }, { path:'message', component:Message, children:[ { name:\"detail\", path:'detail', component:Detail } ] } ] }, ] }) App.vue About Home--> About Home import Banner from \"@/components/Banner\"; export default { name: 'App', components:{ Banner }, } /*base*/ body { background: #fff; } Message.vue &nbsp;&nbsp;--> &nbsp;&nbsp; export default { name: \"messages\", data(){ return { messageList:[ {id:\"001\",title:\"消息001\"}, {id:\"002\",title:\"消息002\"}, {id:\"003\",title:\"消息003\"}, ] } } } 🚀总结 嵌套路由的编写方式： 在index中被嵌套的路由下面写一个children配置项，注意path不用带\"/\" router-link中写路由的全路径：/home/message 路由的query参数 路由跳转时可以带query参数，如果是动态数据，可以使用:to+模板字符串完成，还有一种更加通用的对象写法如下 接收query参数使用$route.query.xxx Message.vue &nbsp;&nbsp;--> &nbsp;&nbsp; export default { name: \"messages\", data(){ return { messageList:[ {id:\"001\",title:\"消息001\"}, {id:\"002\",title:\"消息002\"}, {id:\"003\",title:\"消息003\"}, ] } } } 路由的params参数 路由带参可以使用params参数，比如/home/message/detail/001/math，其中detail及之前的都是路由配置，后面的是参数，写法如下 params参数需要必须跟name属性配合，path不支持 router/index.js //该文件专门用于创建应用的路由器 import VueRouter from \"vue-router\" import About from \"@/pages/About\"; import Home from \"@/pages/Home\"; import News from \"@/pages/News\"; import Message from \"@/pages/Messages\"; import Detail from \"@/pages/Detail\"; //创建一个路由器 export default new VueRouter({ routes:[ { name:\"about\", path:'/about', component:About, }, { path:'/home', component:Home, children:[ { path:'news', component:News }, { path:'message', component:Message, children:[ { name:\"detail\", path:'detail/:id/:title', component:Detail } ] } ] }, ] }) Message.vue &nbsp;&nbsp;--> &nbsp;&nbsp; export default { name: \"messages\", data(){ return { messageList:[ {id:\"001\",title:\"消息001\"}, {id:\"002\",title:\"消息002\"}, {id:\"003\",title:\"消息003\"}, ] } } } 路由的pops参数 router/index.js //该文件专门用于创建应用的路由器 import VueRouter from \"vue-router\" import About from \"@/pages/About\"; import Home from \"@/pages/Home\"; import News from \"@/pages/News\"; import Message from \"@/pages/Messages\"; import Detail from \"@/pages/Detail\"; //创建一个路由器 export default new VueRouter({ routes:[ { name:\"about\", path:'/about', component:About, }, { path:'/home', component:Home, children:[ { path:'news', component:News }, { path:'message', component:Message, children:[ { name:\"detail\", path:'detail', component:Detail, //第一种写法：props为值对象，该对象所有的的k-v最终都会通过props传递给Detail组件 // props:{id:100,title:\"amir\"} //第二种写法：props为布尔值，路由收到的所有params参数通过props传递给Detail组件 // props:true //第三种写法：props值为函数，该函数返回对象中每一组k-v都会通过props传递给Detail组件 props($route){ return { id:$route.query.id, title:$route.query.title } } } ] } ] }, ] }) Detail.vue 消息编号： 消息标题： export default { name: \"Detail\", props:['id','title'] } 路由对历史记录的影响 一般的在同一个网站访问，历史记录会保存在在一个列表结构中，用户点前进或者后退当前指向指针发生变化，就会改变当前浏览的页面。 router-link提供了一个replace属性，其值为bool值。replace作用是替换掉当前记录。 Home组件内容 News Message export default { name: \"Home\" } 1513 words "},"chapter4/7-编程式路由导航.html":{"url":"chapter4/7-编程式路由导航.html","title":"7. 编程式路由导航","keywords":"","body":"🛴编程式路由导航 不借助router-link实现路由跳转，让路由跳转更加灵活， 主要使用$router上的函数通过事件触发跳转 基本使用 &nbsp;&nbsp; &nbsp;&nbsp;--> 点击跳转到about 点击跳转到首页 点击前进 点击后退 点击go export default { name: \"messages\", data(){ return { messageList:[ {id:\"001\",title:\"消息001\"}, {id:\"002\",title:\"消息002\"}, {id:\"003\",title:\"消息003\"}, ] } }, methods:{ goAbout(){ this.$router.push({ name:\"about\", }) }, goIndex(){ this.$router.push({ path:\"/\", }) }, forward(){ this.$router.forward() }, back(){ this.$router.back() }, go(){ this.$router.go(-1) //负数标识后退，正数表示前进 } } } 跳转的时候可以带参数 &nbsp;&nbsp; &nbsp;&nbsp;--> 点击查看detail export default { name: \"messages\", data(){ return { messageList:[ {id:\"001\",title:\"消息001\"}, {id:\"002\",title:\"消息002\"}, {id:\"003\",title:\"消息003\"}, ] } }, methods:{ viewDetail(message){ this.$router.push({ name:\"detail\", query:{ id:message.id, title:message.title } }) } } } 344 words "},"chapter4/8-缓存路由组件.html":{"url":"chapter4/8-缓存路由组件.html","title":"8. 缓存路由组件","keywords":"","body":"🛴缓存路由组件的目的 路由的切换会销毁当前组件,但是有时候我们期望路由跳转后页面信息能够保存下来,下次进来直接使用,此时就需要使用到缓存路由组件的相关技术了. 缓存News组件 注意缓存的组件最终展示在哪个组件中就在哪个组件中写缓存逻辑. News.vue news001 news002 news003 export default { name: \"News\" } input { display: block; } Home.vue Home组件内容 News Message export default { name: \"Home\" } include的写法 include=\"News\" include=\"News,Messages\" :include=\"['News','Messages']\"] 注意里面都是组件名称,如果不写则会缓存全部 254 words "},"chapter4/9-两个router的生命周期钩子.html":{"url":"chapter4/9-两个router的生命周期钩子.html","title":"9. 两个router的生命周期钩子","keywords":"","body":"🛴需求 在News组件中添加一行文字,让其不opacity样式动态变化 欢迎学习router news001 news002 news003 export default { name: \"News\", data(){ return{ opacity:1 } }, mounted() { this.timer = setInterval(()=>{ console.log(\"定时器被执行了\") this.opacity -= 0.01 if(this.opacity input { display: block; } 问题是,我们已经在Home组件中给News设置了keep-alive,所以不会销毁定时器了,这样就会造成资源的浪费,使用vue-router提供的生命周期钩子可以解决这个问题 欢迎学习router news001 news002 news003 export default { name: \"News\", data(){ return{ opacity:1 } }, activated() { this.timer = setInterval(()=>{ console.log(\"定时器被执行了\") this.opacity -= 0.01 if(this.opacity input { display: block; } 🚀总结 activated,在组件呈现在用户眼前的时候生效 deactivated,在组件在界面消失的时候生效 253 words "},"chapter4/10-路由守卫.html":{"url":"chapter4/10-路由守卫.html","title":"10. 路由守卫","keywords":"","body":"🛴全局路由守卫 路由守卫相当于中间件或者说切面,添加之后所有的路由跳转可以经由此处,可以做权限校验之类的工作. vue-router中全局路由守卫常用的有:前置路由守卫\\后置路由守卫,前置路由守卫在每次路由切换之前被调用,后置路由守卫在每次路由切换之后被调用 配置 路由守卫需要给每一个路由设置一个name //该文件专门用于创建应用的路由器 import VueRouter from \"vue-router\" import About from \"@/pages/About\"; import Home from \"@/pages/Home\"; import News from \"@/pages/News\"; import Message from \"@/pages/Messages\"; import Detail from \"@/pages/Detail\"; //创建一个路由器 const router = new VueRouter({ routes:[ { name:\"about\", path:'/about', component:About, meta:{isAuth:false,title:\"关于\"} }, { path:'/home', component:Home, meta:{isAuth:false,title:\"首页\"}, children:[ { name:\"news\", path:'news', component:News, meta:{isAuth:true,title:\"新闻\"}, }, { name:\"massages\", path:'message', component:Message, meta:{isAuth:true,title:\"信息\"}, children:[ { name:\"detail\", path:'detail', component:Detail, meta:{isAuth:true,title:\"信息列表\"}, //第一种写法：props为值对象，该对象所有的的k-v最终都会通过props传递给Detail组件 // props:{id:100,title:\"amir\"} //第二种写法：props为布尔值，路由收到的所有params参数通过props传递给Detail组件 // props:true //第三种写法：props值为函数，该函数返回对象中每一组k-v都会通过props传递给Detail组件 props($route){ return { id:$route.query.id, title:$route.query.title } } } ] } ] }, ] }) //前置路由守卫 router.beforeEach((to,from,next)=>{ console.log(from) if(!to.meta['isAuth']){ next() }else{ if(localStorage.getItem('name')===\"amir\"){ next() }else{ alert(\"权限不足\") } } }) //后置路由守卫 router.afterEach((to,from)=>{ console.log(from) document.title = to.meta['title'] || \"用户管理系统\" }) export default router 🛴独享路由守卫 独享路由守卫只给某一个路由配置 index.js //该文件专门用于创建应用的路由器 import VueRouter from \"vue-router\" import About from \"@/pages/About\"; import Home from \"@/pages/Home\"; import News from \"@/pages/News\"; import Message from \"@/pages/Messages\"; import Detail from \"@/pages/Detail\"; //创建一个路由器 const router = new VueRouter({ routes:[ { name:\"about\", path:'/about', component:About, meta:{isAuth:false,title:\"关于\"} }, { path:'/home', component:Home, meta:{isAuth:false,title:\"首页\"}, children:[ { name:\"news\", path:'news', component:News, meta:{isAuth:true,title:\"新闻\"}, }, { name:\"massages\", path:'message', component:Message, meta:{isAuth:true,title:\"信息\"}, children:[ { name:\"detail\", path:'detail', component:Detail, meta:{isAuth:true,title:\"信息列表\"}, //第一种写法：props为值对象，该对象所有的的k-v最终都会通过props传递给Detail组件 // props:{id:100,title:\"amir\"} //第二种写法：props为布尔值，路由收到的所有params参数通过props传递给Detail组件 // props:true //第三种写法：props值为函数，该函数返回对象中每一组k-v都会通过props传递给Detail组件 props($route){ return { id:$route.query.id, title:$route.query.title } }, beforeEnter(to,from,next){ if(localStorage.getItem('password')==='123'){ next() }else { alert(\"权限不足\") } } } ] } ] }, ] }) //前置路由守卫 router.beforeEach((to,from,next)=>{ console.log(from) if(!to.meta['isAuth']){ next() }else{ if(localStorage.getItem('name')===\"amir\"){ next() }else{ alert(\"权限不足\") } } }) //后置路由守卫 router.afterEach((to,from)=>{ console.log(from) document.title = to.meta['title'] || \"用户管理系统\" }) export default router 以上代码限制了用户查看消息详情的时候判断localstorage是否存在password并且是123,独享路由守卫就这一个beforeEnter,可由配合其他路由守卫一起使用 🛴组件内路由守卫 组件内路由守卫只有在通过路由规则匹配进入/离开的时候触发,其他方式则不生效 欢迎学习router news001 news002 news003 export default { name: \"News\", data(){ return{ opacity:1 } }, //组件渲染后触发 activated() { this.timer = setInterval(()=>{ console.log(\"定时器被执行了\") this.opacity -= 0.01 if(this.opacity input { display: block; } 994 words "},"chapter4/11-history模式和hash模式.html":{"url":"chapter4/11-history模式和hash模式.html","title":"11. history模式和hash模式","keywords":"","body":"🛴路由器的两种工作模式 对于一个url来说,什么是hash值? ---#及其后面的内容就是hash值 hash值不会包在http请求中,即hash不会带给服务器 hash模式 地址中永远带#号,不美观 如果以后将地址通过第三方手机App分享,若App校验严格,则地址会被标记为不合法 兼容性好 history模式 地址干净\\美观 兼容性比hash略差 应用部署上线后,需要后端人员支持,解决刷新页面服务404的问题 vue中模式的配置 router/indx.js //该文件专门用于创建应用的路由器 import VueRouter from \"vue-router\" import About from \"@/pages/About\"; import Home from \"@/pages/Home\"; import News from \"@/pages/News\"; import Message from \"@/pages/Messages\"; import Detail from \"@/pages/Detail\"; //创建一个路由器 const router = new VueRouter({ mode:\"history\", // mode:\"hash\", //默认的 routes:[ { name:\"about\", path:'/about', component:About, meta:{isAuth:false,title:\"关于\"} }, { path:'/home', component:Home, meta:{isAuth:false,title:\"首页\"}, children:[ { name:\"news\", path:'news', component:News, meta:{isAuth:true,title:\"新闻\"}, }, { name:\"massages\", path:'message', component:Message, meta:{isAuth:true,title:\"信息\"}, children:[ { name:\"detail\", path:'detail', component:Detail, meta:{isAuth:true,title:\"信息列表\"}, //第一种写法：props为值对象，该对象所有的的k-v最终都会通过props传递给Detail组件 // props:{id:100,title:\"amir\"} //第二种写法：props为布尔值，路由收到的所有params参数通过props传递给Detail组件 // props:true //第三种写法：props值为函数，该函数返回对象中每一组k-v都会通过props传递给Detail组件 props($route){ return { id:$route.query.id, title:$route.query.title } }, beforeEnter(to,from,next){ if(localStorage.getItem('password')==='123'){ next() }else { alert(\"权限不足\") } } } ] } ] }, ] }) //前置路由守卫 router.beforeEach((to,from,next)=>{ console.log(from) if(!to.meta['isAuth']){ next() }else{ if(localStorage.getItem('name')===\"amir\"){ next() }else{ alert(\"权限不足\") } } }) //后置路由守卫 router.afterEach((to,from)=>{ console.log(from) document.title = to.meta['title'] || \"用户管理系统\" }) export default router 475 words "}}